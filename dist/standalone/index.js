(()=>{"use strict";var __webpack_modules__={"./src/dataFinalizer/banner.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _types_guards__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../types/guards */ "./src/types/guards.ts");\n/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./helpers */ "./src/dataFinalizer/helpers.ts");\n\r\n\r\nconst finalizeBannerData = (options, remoteData, initialData, failedPlaceholderColor, failedPlaceholderPicture) => {\r\n    if ((0,_types_guards__WEBPACK_IMPORTED_MODULE_0__.isBannerEntity)(remoteData)) {\r\n        remoteData.title = remoteData.title || initialData.title;\r\n        remoteData.banner = (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.finalSuccessfulPictureUrl)(remoteData.banner, options.dataPicUrl, failedPlaceholderPicture);\r\n        remoteData.supportingBackgroundColor = (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.finalSuccessfulBgColor)(remoteData.supportingBackgroundColor, failedPlaceholderColor);\r\n        return remoteData;\r\n    }\r\n    initialData.banner = (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.finalFailedPictureUrl)(options.dataPicUrl, failedPlaceholderPicture);\r\n    initialData.supportingBackgroundColor = (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.finalFailedBgColor)(initialData.banner, failedPlaceholderColor);\r\n    return initialData;\r\n};\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (finalizeBannerData);\r\n\n\n//# sourceURL=webpack:///./src/dataFinalizer/banner.ts?')},"./src/dataFinalizer/base.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _types_guards__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../types/guards */ "./src/types/guards.ts");\n/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./helpers */ "./src/dataFinalizer/helpers.ts");\n\r\n\r\nconst finalizeProfileData = (options, remoteData, initialData, failedPlaceholderColor, failedPlaceholderPicture) => {\r\n    if ((0,_types_guards__WEBPACK_IMPORTED_MODULE_0__.isProfileEntity)(remoteData) || (0,_types_guards__WEBPACK_IMPORTED_MODULE_0__.isNetworkEntity)(remoteData) || (0,_types_guards__WEBPACK_IMPORTED_MODULE_0__.isNodeEntity)(remoteData) || (0,_types_guards__WEBPACK_IMPORTED_MODULE_0__.isAppEntity)(remoteData)) {\r\n        remoteData.title = remoteData.title || initialData.title;\r\n        remoteData.pic = (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.finalSuccessfulPictureUrl)(remoteData.pic, options.dataPicUrl, failedPlaceholderPicture);\r\n        remoteData.supportingBackgroundColor = (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.finalSuccessfulBgColor)(remoteData.supportingBackgroundColor, failedPlaceholderColor);\r\n        return remoteData;\r\n    }\r\n    initialData.pic = (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.finalFailedPictureUrl)(options.dataPicUrl, failedPlaceholderPicture);\r\n    initialData.supportingBackgroundColor = (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.finalFailedBgColor)(initialData.pic, failedPlaceholderColor);\r\n    return initialData;\r\n};\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (finalizeProfileData);\r\n\n\n//# sourceURL=webpack:///./src/dataFinalizer/base.ts?')},"./src/dataFinalizer/failedPlaceholders.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var ___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! .. */ "./src/index.ts");\n/* harmony import */ var _modules_helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../modules/helpers */ "./src/modules/helpers.ts");\n\r\n\r\n// this function return an object of placeholder containing a color and a url, for the case of full failure or missing pictures to show on failure effect\r\nconst getFailedPlaceholders = (options, initialPlaceholder) => {\r\n    const placeholders = { color: "transparent", url: "" };\r\n    if (options.FailureEffect === "transparent") {\r\n        return placeholders;\r\n    }\r\n    if (options.placeholder === "randomColor") {\r\n        if (initialPlaceholder.color && options.loadingEffect === "randomColor") {\r\n            placeholders.color = initialPlaceholder.color;\r\n            return placeholders;\r\n        }\r\n        placeholders.color = (0,_modules_helpers__WEBPACK_IMPORTED_MODULE_1__.getRandomColor)();\r\n        return placeholders;\r\n    }\r\n    let possbileBgColor = options.placeholder?.match(___WEBPACK_IMPORTED_MODULE_0__.davinciPicsConfig.colorRegex);\r\n    if (possbileBgColor) {\r\n        placeholders.color = possbileBgColor[0];\r\n        return placeholders;\r\n    }\r\n    placeholders.url = (0,_modules_helpers__WEBPACK_IMPORTED_MODULE_1__.getMissingURL)(options.type, options.placeholder);\r\n    return placeholders;\r\n};\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (getFailedPlaceholders);\r\n\n\n//# sourceURL=webpack:///./src/dataFinalizer/failedPlaceholders.ts?')},"./src/dataFinalizer/helpers.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   finalFailedBgColor: () => (/* binding */ finalFailedBgColor),\n/* harmony export */   finalFailedPictureUrl: () => (/* binding */ finalFailedPictureUrl),\n/* harmony export */   finalSuccessfulBgColor: () => (/* binding */ finalSuccessfulBgColor),\n/* harmony export */   finalSuccessfulPictureUrl: () => (/* binding */ finalSuccessfulPictureUrl)\n/* harmony export */ });\nconst finalSuccessfulPictureUrl = (remotePictureUrl, localPictureUrl = "", failedPlaceholderPicture) => {\r\n    return remotePictureUrl || localPictureUrl || failedPlaceholderPicture;\r\n};\r\nconst finalFailedPictureUrl = (localPictureUrl = "", failedPlaceholderPicture) => {\r\n    return localPictureUrl || failedPlaceholderPicture;\r\n};\r\nconst finalSuccessfulBgColor = (remoteColor, placeholderColor) => {\r\n    return remoteColor ? remoteColor || "transparent" : placeholderColor;\r\n};\r\nconst finalFailedBgColor = (finalPictureUrl, placeholderColor) => {\r\n    return !finalPictureUrl ? placeholderColor : "transparent";\r\n};\r\n\n\n//# sourceURL=webpack:///./src/dataFinalizer/helpers.ts?')},"./src/dataFinalizer/index.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _banner__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./banner */ "./src/dataFinalizer/banner.ts");\n/* harmony import */ var _failedPlaceholders__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./failedPlaceholders */ "./src/dataFinalizer/failedPlaceholders.ts");\n/* harmony import */ var _types_guards__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../types/guards */ "./src/types/guards.ts");\n/* harmony import */ var _token__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./token */ "./src/dataFinalizer/token.ts");\n/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./base */ "./src/dataFinalizer/base.ts");\n\r\n\r\n\r\n\r\n\r\n/**\r\n * This functions will combine the remote data with possible alternative data or placeholders\r\n * @param initialData The data which was initally was constructed for the element\r\n * @param remoteData The data which was retrieved from the API\r\n * @param options The attributes\r\n * @param placeholders The placeholders, which was initially generated for the loading purposes\r\n * @returns\r\n */\r\nconst finalizeData = (initialData, remoteData, options, placeholders) => {\r\n    const { color: failedPlaceholderColor, url: failedPlaceholderPicture } = (0,_failedPlaceholders__WEBPACK_IMPORTED_MODULE_1__["default"])(options, placeholders);\r\n    if (options.type === "token") {\r\n        return (0,_token__WEBPACK_IMPORTED_MODULE_3__["default"])(options, initialData, remoteData, failedPlaceholderPicture, failedPlaceholderColor);\r\n    }\r\n    if (options.type === "profile" && (0,_types_guards__WEBPACK_IMPORTED_MODULE_2__.isProfileEntity)(initialData)) {\r\n        return (0,_base__WEBPACK_IMPORTED_MODULE_4__["default"])(options, remoteData, initialData, failedPlaceholderColor, failedPlaceholderPicture);\r\n    }\r\n    if (options.type === "banner" && (0,_types_guards__WEBPACK_IMPORTED_MODULE_2__.isBannerEntity)(initialData)) {\r\n        return (0,_banner__WEBPACK_IMPORTED_MODULE_0__["default"])(options, remoteData, initialData, failedPlaceholderColor, failedPlaceholderPicture);\r\n    }\r\n    if (options.type === "node" && (0,_types_guards__WEBPACK_IMPORTED_MODULE_2__.isNodeEntity)(initialData)) {\r\n        return (0,_base__WEBPACK_IMPORTED_MODULE_4__["default"])(options, remoteData, initialData, failedPlaceholderColor, failedPlaceholderPicture);\r\n    }\r\n    if (options.type === "network" && (0,_types_guards__WEBPACK_IMPORTED_MODULE_2__.isNetworkEntity)(initialData)) {\r\n        return (0,_base__WEBPACK_IMPORTED_MODULE_4__["default"])(options, remoteData, initialData, failedPlaceholderColor, failedPlaceholderPicture);\r\n    }\r\n    if (options.type === "app" && (0,_types_guards__WEBPACK_IMPORTED_MODULE_2__.isAppEntity)(initialData)) {\r\n        return (0,_base__WEBPACK_IMPORTED_MODULE_4__["default"])(options, remoteData, initialData, failedPlaceholderColor, failedPlaceholderPicture);\r\n    }\r\n    throw new Error(`Data couldn\'t be finalized, missing type. ${options?.type}`);\r\n};\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (finalizeData);\r\n\n\n//# sourceURL=webpack:///./src/dataFinalizer/index.ts?')},"./src/dataFinalizer/token.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _types_guards__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../types/guards */ "./src/types/guards.ts");\n/* harmony import */ var _tokens_lp__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./tokens/lp */ "./src/dataFinalizer/tokens/lp.ts");\n/* harmony import */ var _tokens_wrapped__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./tokens/wrapped */ "./src/dataFinalizer/tokens/wrapped.ts");\n/* harmony import */ var _tokens_simple__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./tokens/simple */ "./src/dataFinalizer/tokens/simple.ts");\n\r\n\r\n\r\n\r\nconst finalizeTokenData = (options, initialData, remoteData, failedPlaceholderPicture, failedPlaceholderColor) => {\r\n    if (!remoteData?.type) {\r\n        // no remote data\r\n        if ((0,_types_guards__WEBPACK_IMPORTED_MODULE_0__.isLpTokenEntity)(initialData)) {\r\n            return (0,_tokens_lp__WEBPACK_IMPORTED_MODULE_1__.finalizeFailedLpData)(options, initialData, failedPlaceholderColor, failedPlaceholderPicture);\r\n        }\r\n        if ((0,_types_guards__WEBPACK_IMPORTED_MODULE_0__.isWrappedTokenEntity)(initialData)) {\r\n            return (0,_tokens_wrapped__WEBPACK_IMPORTED_MODULE_2__.finalizeFailedWrappedData)(options, initialData, failedPlaceholderColor, failedPlaceholderPicture);\r\n        }\r\n        if ((0,_types_guards__WEBPACK_IMPORTED_MODULE_0__.isTokenEntity)(initialData)) {\r\n            return (0,_tokens_simple__WEBPACK_IMPORTED_MODULE_3__.finalizeFailedSimpleTokenData)(options, initialData, failedPlaceholderColor, failedPlaceholderPicture);\r\n        }\r\n    }\r\n    if ((0,_types_guards__WEBPACK_IMPORTED_MODULE_0__.isLpTokenEntity)(remoteData)) {\r\n        return (0,_tokens_lp__WEBPACK_IMPORTED_MODULE_1__.finalizeSuccessfulLpData)(options, remoteData, failedPlaceholderColor, failedPlaceholderPicture);\r\n    }\r\n    if ((0,_types_guards__WEBPACK_IMPORTED_MODULE_0__.isWrappedTokenEntity)(remoteData)) {\r\n        return (0,_tokens_wrapped__WEBPACK_IMPORTED_MODULE_2__.finalizeSuccessfulWrappedData)(options, remoteData, failedPlaceholderColor, failedPlaceholderPicture);\r\n    }\r\n    if ((0,_types_guards__WEBPACK_IMPORTED_MODULE_0__.isTokenEntity)(remoteData)) {\r\n        return (0,_tokens_simple__WEBPACK_IMPORTED_MODULE_3__.finalizeSuccessfulSimpleTokenData)(options, remoteData, failedPlaceholderColor, failedPlaceholderPicture);\r\n    }\r\n    throw new Error(`Data couldn\'t be finalized for the token, failed to combine data.`);\r\n};\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (finalizeTokenData);\r\n\n\n//# sourceURL=webpack:///./src/dataFinalizer/token.ts?')},"./src/dataFinalizer/tokens/lp.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   finalizeFailedLpData: () => (/* binding */ finalizeFailedLpData),\n/* harmony export */   finalizeSuccessfulLpData: () => (/* binding */ finalizeSuccessfulLpData)\n/* harmony export */ });\n/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../helpers */ "./src/dataFinalizer/helpers.ts");\n\r\nconst finalizeFailedLpData = (options, initialData, failedPlaceholderColor, failedPlaceholderPicture) => {\r\n    const { token0Pic, token1Pic } = getLocalLpData(options);\r\n    initialData.token0.pic = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.finalFailedPictureUrl)(token0Pic, failedPlaceholderPicture);\r\n    initialData.token0.supportingBackgroundColor = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.finalFailedBgColor)(initialData.token0.pic, failedPlaceholderColor);\r\n    initialData.token1.pic = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.finalFailedPictureUrl)(token1Pic, failedPlaceholderPicture);\r\n    initialData.token1.supportingBackgroundColor = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.finalFailedBgColor)(initialData.token1.pic, failedPlaceholderColor);\r\n    if (initialData.app && options.context === "app") {\r\n        initialData.app.pic = options.dataContextPicUrl || "";\r\n        initialData.app.supportingBackgroundColor = "";\r\n    }\r\n    initialData.network.pic = options.dataContextPicUrl || "";\r\n    initialData.network.supportingBackgroundColor = "";\r\n    return initialData;\r\n};\r\nconst finalizeSuccessfulLpData = (options, remoteData, failedPlaceholderColor, failedPlaceholderPicture) => {\r\n    const { token0Title, token1Title, token0Pic, token1Pic } = getLocalLpData(options);\r\n    remoteData.token0.title = remoteData.token0.title || token0Title;\r\n    remoteData.token0.pic = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.finalSuccessfulPictureUrl)(remoteData.token0.pic, token0Pic, failedPlaceholderPicture);\r\n    remoteData.token0.supportingBackgroundColor = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.finalSuccessfulBgColor)(remoteData.token0.supportingBackgroundColor, failedPlaceholderColor);\r\n    remoteData.token1.title = remoteData.token1.title || token1Title;\r\n    remoteData.token1.pic = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.finalSuccessfulPictureUrl)(remoteData.token1.pic, token1Pic, failedPlaceholderPicture);\r\n    remoteData.token1.supportingBackgroundColor = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.finalSuccessfulBgColor)(remoteData.token1.supportingBackgroundColor, failedPlaceholderColor);\r\n    if (remoteData.app) {\r\n        remoteData.app.title = remoteData.app?.title || options.dataContextTitle || "";\r\n        remoteData.app.pic = remoteData.app?.pic || options.dataContextPicUrl || "";\r\n        remoteData.app.supportingBackgroundColor = remoteData.app?.supportingBackgroundColor || "";\r\n    }\r\n    remoteData.network.title = remoteData.network.title || options.dataContextTitle || "";\r\n    remoteData.network.pic = remoteData.network.pic || options.dataContextPicUrl || failedPlaceholderPicture;\r\n    remoteData.network.supportingBackgroundColor = remoteData.network.supportingBackgroundColor || "";\r\n    return remoteData;\r\n};\r\nconst getLocalLpData = (options) => {\r\n    let token0Pic = "", token1Pic = "", token0Title = "", token1Title = "";\r\n    if (options.dataPicUrl?.includes("|")) {\r\n        const lpUrls = options.dataPicUrl.split("|");\r\n        token0Pic = lpUrls[0];\r\n        token1Pic = lpUrls[1];\r\n    }\r\n    if (options.dataTitle?.includes("|")) {\r\n        const lpTitles = options.dataTitle.split("|");\r\n        token0Title = lpTitles[0];\r\n        token1Title = lpTitles[1];\r\n    }\r\n    return { token0Pic, token1Pic, token0Title, token1Title };\r\n};\r\n\n\n//# sourceURL=webpack:///./src/dataFinalizer/tokens/lp.ts?')},"./src/dataFinalizer/tokens/simple.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   finalizeFailedSimpleTokenData: () => (/* binding */ finalizeFailedSimpleTokenData),\n/* harmony export */   finalizeSuccessfulSimpleTokenData: () => (/* binding */ finalizeSuccessfulSimpleTokenData)\n/* harmony export */ });\n/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../helpers */ "./src/dataFinalizer/helpers.ts");\n\r\nconst finalizeFailedSimpleTokenData = (options, initialData, failedPlaceholderColor, failedPlaceholderPicture) => {\r\n    initialData.pic = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.finalFailedPictureUrl)(options.dataPicUrl, failedPlaceholderPicture);\r\n    initialData.supportingBackgroundColor = !initialData.pic ? failedPlaceholderColor : "transparent";\r\n    initialData.network.pic = options.dataContextPicUrl || "";\r\n    initialData.network.supportingBackgroundColor = "";\r\n    return initialData;\r\n};\r\nconst finalizeSuccessfulSimpleTokenData = (options, remoteData, failedPlaceholderColor, failedPlaceholderPicture) => {\r\n    remoteData.title = remoteData.title || options.dataTitle || "";\r\n    remoteData.pic = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.finalSuccessfulPictureUrl)(remoteData.pic, options.dataPicUrl, failedPlaceholderPicture);\r\n    remoteData.supportingBackgroundColor = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.finalSuccessfulBgColor)(remoteData.supportingBackgroundColor, failedPlaceholderColor);\r\n    remoteData.network.title = remoteData.network.title || options.dataContextTitle || "";\r\n    remoteData.network.pic = remoteData.network.pic || failedPlaceholderPicture;\r\n    remoteData.network.supportingBackgroundColor = remoteData.network.supportingBackgroundColor || failedPlaceholderColor;\r\n    return remoteData;\r\n};\r\n\n\n//# sourceURL=webpack:///./src/dataFinalizer/tokens/simple.ts?')},"./src/dataFinalizer/tokens/wrapped.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   finalizeFailedWrappedData: () => (/* binding */ finalizeFailedWrappedData),\n/* harmony export */   finalizeSuccessfulWrappedData: () => (/* binding */ finalizeSuccessfulWrappedData)\n/* harmony export */ });\n/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../helpers */ "./src/dataFinalizer/helpers.ts");\n\r\nconst finalizeFailedWrappedData = (options, initialData, failedPlaceholderColor, failedPlaceholderPicture) => {\r\n    initialData.originalToken.pic = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.finalFailedPictureUrl)(options.dataPicUrl, failedPlaceholderPicture);\r\n    initialData.originalToken.supportingBackgroundColor = !initialData.originalToken.pic ? failedPlaceholderColor : "transparent";\r\n    if (initialData.app && options.context === "app") {\r\n        initialData.app.pic = options.dataContextPicUrl || "";\r\n        initialData.app.supportingBackgroundColor = "";\r\n    }\r\n    initialData.network.pic = options.dataContextPicUrl || "";\r\n    initialData.network.supportingBackgroundColor = "";\r\n    return initialData;\r\n};\r\nconst finalizeSuccessfulWrappedData = (options, remoteData, failedPlaceholderColor, failedPlaceholderPicture) => {\r\n    remoteData.originalToken.title = remoteData.originalToken.title || options.dataTitle || "";\r\n    remoteData.originalToken.pic = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.finalSuccessfulPictureUrl)(remoteData.originalToken.pic, options.dataContextPicUrl, failedPlaceholderPicture);\r\n    remoteData.originalToken.supportingBackgroundColor = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.finalSuccessfulBgColor)(remoteData.originalToken.supportingBackgroundColor, failedPlaceholderColor);\r\n    if (remoteData.app) {\r\n        remoteData.app.title = remoteData?.app?.title || options.dataContextTitle || "";\r\n        remoteData.app.pic = remoteData?.app?.pic || options.dataContextPicUrl || "";\r\n        remoteData.app.supportingBackgroundColor = remoteData?.app?.supportingBackgroundColor || "transparent";\r\n    }\r\n    remoteData.network.title = remoteData.network.title || options.dataContextTitle || "";\r\n    remoteData.network.pic = remoteData.network.pic || options.dataContextTitle || failedPlaceholderPicture;\r\n    remoteData.network.supportingBackgroundColor = remoteData.network?.supportingBackgroundColor || "transparent";\r\n    return remoteData;\r\n};\r\n\n\n//# sourceURL=webpack:///./src/dataFinalizer/tokens/wrapped.ts?')},"./src/index.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DavinciPic: () => (/* binding */ DavinciPic),\n/* harmony export */   davinciPicsConfig: () => (/* binding */ davinciPicsConfig)\n/* harmony export */ });\n/* harmony import */ var _modules_dataLoader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./modules/dataLoader */ "./src/modules/dataLoader.ts");\n/* harmony import */ var _dataFinalizer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./dataFinalizer */ "./src/dataFinalizer/index.ts");\n/* harmony import */ var _modules_attributeIntegrator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./modules/attributeIntegrator */ "./src/modules/attributeIntegrator.ts");\n/* harmony import */ var _modules_dataInitializer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./modules/dataInitializer */ "./src/modules/dataInitializer.ts");\n/* harmony import */ var _svgGenerator__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./svgGenerator */ "./src/svgGenerator/index.ts");\n/* harmony import */ var _svgUpdator__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./svgUpdator */ "./src/svgUpdator/index.ts");\n/* harmony import */ var _types_guards__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./types/guards */ "./src/types/guards.ts");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nlet davinciPicsConfig = {\r\n    apiUrl: "https://davincigraph.art/api/v1",\r\n    counter: 0,\r\n    colorRegex: /#(?:[0-9A-Fa-f]{3}){1,2}|rgb\\(\\s*\\d+\\s*,\\s*\\d+\\s*,\\s*\\d+\\s*\\)|transparent/,\r\n};\r\n/**\r\n * The DavinciPic class is a custom HTML element that encapsulates the logic for\r\n * fetching and displaying various types of images based on the PicsType.\r\n *\r\n * This element provides several customizable attributes like `type`, `address`, `network`, etc.\r\n * to configure its behavior. It supports both online and offline modes, fetching data\r\n * via the DataLoader class or using provided attributes in the offline mode.\r\n *\r\n * The class utilizes IntersectionObserver to fetch data when the element scrolls into view.\r\n * It uses the SvgGenerator for rendering SVG based on the fetched or provided data.\r\n *\r\n * Author: Davincigraph Team\r\n *\r\n * Usage:\r\n * <davinci-pic type="token" address="someAddress" network="hedera"></davinci-pic>\r\n *\r\n * The class also handles various edge cases like missing data and allows fallback mechanisms.\r\n */\r\nclass DavinciPic extends HTMLElement {\r\n    set type(value) {\r\n        this.setAttribute("type", value);\r\n    }\r\n    get type() {\r\n        const value = this.getAttribute("type");\r\n        if (value && (0,_types_guards__WEBPACK_IMPORTED_MODULE_6__.isPicsType)(value)) {\r\n            return value;\r\n        }\r\n        throw new Error("Type is mandatory.");\r\n    }\r\n    set network(value) {\r\n        this.setAttribute("network", value);\r\n    }\r\n    get network() {\r\n        const value = this.getAttribute("network");\r\n        if (this.type !== "app" && !value) {\r\n            throw new Error("Network is not defined on the element.");\r\n        }\r\n        return value || "";\r\n    }\r\n    set address(value) {\r\n        this.setAttribute("address", value);\r\n    }\r\n    // arbitrary on network entities and on offline mode\r\n    get address() {\r\n        const value = this.getAttribute("address");\r\n        if (this.type !== "app" && this.type !== "network" && !value) {\r\n            throw new Error("Network is not defined on the element.");\r\n        }\r\n        return value || "";\r\n    }\r\n    set name(value) {\r\n        this.setAttribute("name", value);\r\n    }\r\n    // arbitrary on network entities and on offline mode\r\n    get name() {\r\n        const value = this.getAttribute("name");\r\n        if (this.type === "app" && value) {\r\n            return value;\r\n        }\r\n        throw new Error("Name is necessary for an app.");\r\n    }\r\n    set offlineMode(value) {\r\n        value ? this.setAttribute("offline-mode", "") : this.removeAttribute("offline-mode");\r\n    }\r\n    get offlineMode() {\r\n        return this.hasAttribute("offline-mode");\r\n    }\r\n    set complexTokenType(value) {\r\n        if (this.type === "token") {\r\n            throw new Error("Complex token type is specifically for token type.");\r\n        }\r\n        if (value !== "lp" && value !== "wrapped") {\r\n            throw new Error("The value given for complex token type is invalid.");\r\n        }\r\n        this.setAttribute("complex-token-type", value);\r\n    }\r\n    get complexTokenType() {\r\n        const value = this.getAttribute("complex-token-type");\r\n        if (value === "lp" || value === "wrapped") {\r\n            return value;\r\n        }\r\n        return undefined;\r\n    }\r\n    // not applies to banner\r\n    set size(value) {\r\n        this.setAttribute("size", value.toString());\r\n    }\r\n    // not applies to banner\r\n    get size() {\r\n        const value = this.getAttribute("size");\r\n        return value ? parseFloat(value) : 100;\r\n    }\r\n    // not applies to complex and contextual tokens\r\n    set shape(value) {\r\n        this.setAttribute("shape", value);\r\n    }\r\n    // not applies to complex and contextual tokens\r\n    get shape() {\r\n        const value = this.getAttribute("shape");\r\n        return (0,_types_guards__WEBPACK_IMPORTED_MODULE_6__.isPicsShapeType)(value) ? value : "circle";\r\n    }\r\n    // only applies to token, specifically Wrapped and liquidity\r\n    set context(value) {\r\n        this.setAttribute("context", value);\r\n    }\r\n    // only applies to token, specifically Wrapped and liquidity\r\n    get context() {\r\n        const value = this.getAttribute("context");\r\n        return (0,_types_guards__WEBPACK_IMPORTED_MODULE_6__.isPicsContextType)(value) ? value : "app";\r\n    }\r\n    // only applies to token, specifically Wrapped and liquidity\r\n    set contextPosition(value) {\r\n        this.setAttribute("context-position", value);\r\n    }\r\n    // only applies to token, specifically Wrapped and liquidity\r\n    get contextPosition() {\r\n        const value = this.getAttribute("context-position");\r\n        return (0,_types_guards__WEBPACK_IMPORTED_MODULE_6__.isPicsContextPositionType)(value) ? value : "bottomRight";\r\n    }\r\n    // not applies to banner\r\n    set strokeWidth(value) {\r\n        this.setAttribute("stroke-width", value.toString());\r\n    }\r\n    // not applies to banner\r\n    get strokeWidth() {\r\n        const value = this.getAttribute("stroke-width");\r\n        return value && !isNaN(Number(value)) ? parseFloat(value) : 0;\r\n    }\r\n    // not applies to banner\r\n    set strokeColor(value) {\r\n        this.setAttribute("stroke-color", value);\r\n    }\r\n    // not applies to banner\r\n    get strokeColor() {\r\n        return this.getAttribute("stroke-color") || "gray";\r\n    }\r\n    set censor(value) {\r\n        this.setAttribute("censor", value);\r\n    }\r\n    get censor() {\r\n        const value = this.getAttribute("censor");\r\n        return (0,_types_guards__WEBPACK_IMPORTED_MODULE_6__.isPicsSensitivityType)(value) ? value : "copyright-violated";\r\n    }\r\n    set dataTitle(value) {\r\n        this.setAttribute("data-type", value);\r\n    }\r\n    get dataTitle() {\r\n        return this.getAttribute("data-title") || "";\r\n    }\r\n    set dataPicUrl(value) {\r\n        this.setAttribute("data-pic-url", value);\r\n    }\r\n    get dataPicUrl() {\r\n        return this.getAttribute("data-pic-url") || "";\r\n    }\r\n    // only applies to token, specifically Wrapped and liquidity\r\n    set dataContextTitle(value) {\r\n        this.setAttribute("data-context-title", value);\r\n    }\r\n    // only applies to token, specifically Wrapped and liquidity\r\n    get dataContextTitle() {\r\n        return this.getAttribute("data-context-title") || "";\r\n    }\r\n    // only applies to token, specifically Wrapped and liquidity\r\n    set dataContextPicUrl(value) {\r\n        this.setAttribute("data-context-pic-url", value);\r\n    }\r\n    // only applies to token, specifically Wrapped and liquidity\r\n    get dataContextPicUrl() {\r\n        return this.getAttribute("data-context-pic-url") || "";\r\n    }\r\n    set placeholder(value) {\r\n        this.setAttribute("placeholder", value);\r\n    }\r\n    get placeholder() {\r\n        return this.getAttribute("placeholder") || "default";\r\n    }\r\n    set loadingEffect(value) {\r\n        this.setAttribute("loading-effect", value);\r\n    }\r\n    get loadingEffect() {\r\n        return this.getAttribute("loading-effect") || "transparent";\r\n    }\r\n    set FailureEffect(value) {\r\n        this.setAttribute("failure-effect", value);\r\n    }\r\n    get FailureEffect() {\r\n        return this.getAttribute("failure-effect") || "placeholder";\r\n    }\r\n    set delayResponseTime(value) {\r\n        this.setAttribute("delay-response-time", value.toString());\r\n    }\r\n    get delayResponseTime() {\r\n        const value = this.getAttribute("delay-response-time");\r\n        return value && !isNaN(Number(value)) ? parseFloat(value) : 0;\r\n    }\r\n    observer;\r\n    interval;\r\n    constructor() {\r\n        super();\r\n        this.observer = new IntersectionObserver(this.handleIntersection.bind(this), { root: null, rootMargin: "200px 0px", threshold: 0 });\r\n    }\r\n    connectedCallback() {\r\n        this.style.display = "inline-block";\r\n        this.style.verticalAlign = "top";\r\n        this.style.transition = "opacity 1s";\r\n        this.style.opacity = "1";\r\n        this.observer.observe(this);\r\n    }\r\n    disconnectedCallback() {\r\n        this.observer.unobserve(this);\r\n        this.clearInterval();\r\n    }\r\n    /**\r\n     * when the component reached viewport, get the data and generate the appropriate picture\r\n     * @param entries\r\n     * @param observer\r\n     */\r\n    async handleIntersection(entries, observer) {\r\n        for (const entry of entries) {\r\n            if (entry.isIntersecting) {\r\n                observer.unobserve(entry.target);\r\n                try {\r\n                    // integrate attributes to an object\r\n                    const attributes = (0,_modules_attributeIntegrator__WEBPACK_IMPORTED_MODULE_2__["default"])(this);\r\n                    // get loading placeholders\r\n                    const placeholders = (0,_modules_dataInitializer__WEBPACK_IMPORTED_MODULE_3__.getInitialPlaceholders)((!attributes.loadingEffect || attributes.loadingEffect.endsWith("placeholder")\r\n                        ? attributes.placeholder\r\n                        : attributes.loadingEffect) || "transparent", attributes.type);\r\n                    // construct initial data\r\n                    const initialData = (0,_modules_dataInitializer__WEBPACK_IMPORTED_MODULE_3__["default"])(attributes, placeholders);\r\n                    // generate the svg file\r\n                    let svgElement = (0,_svgGenerator__WEBPACK_IMPORTED_MODULE_4__["default"])(initialData, attributes);\r\n                    // some primary styling\r\n                    if (svgElement) {\r\n                        // during loading stage hide the element is needed\r\n                        svgElement.style.display = attributes.loadingEffect === "hide" ? "none" : "inline";\r\n                        // add the generated svg to the custom element\r\n                        this.appendChild(svgElement);\r\n                        // apply sizes\r\n                        if (attributes.type === "banner") {\r\n                            this.style.width = "100%";\r\n                        }\r\n                        else {\r\n                            this.style.width = `${this.size}px`;\r\n                            this.style.height = `${this.size}px`;\r\n                        }\r\n                        // pulse\r\n                        if (attributes.loadingEffect?.startsWith("pulse") || attributes.loadingEffect?.startsWith("\'pulse")) {\r\n                            this.interval = setInterval(() => {\r\n                                this.style.opacity = this.style.opacity === "1" ? "0.5" : "1";\r\n                            }, 1000);\r\n                        }\r\n                    }\r\n                    // for test purposes\r\n                    await this.delay();\r\n                    // fetch the remote data, or in case of offline mode just an empty object\r\n                    const remoteData = attributes.offlineMode === true ? {} : await (0,_modules_dataLoader__WEBPACK_IMPORTED_MODULE_0__["default"])(attributes);\r\n                    // combine remote data with possible local data and placeholders\r\n                    const finalData = (0,_dataFinalizer__WEBPACK_IMPORTED_MODULE_1__["default"])(initialData, remoteData, attributes, placeholders);\r\n                    // if pulse was activated during loading, remove it\r\n                    this.clearInterval();\r\n                    // a shallow status determining the data presence or not\r\n                    const status = !(0,_types_guards__WEBPACK_IMPORTED_MODULE_6__.isEntityResponseEmpty)(remoteData) || attributes.dataPicUrl ? "success" : "failed";\r\n                    //finalizing\r\n                    if (status === "failed" && attributes.FailureEffect === "hide") {\r\n                        //remove the element if the request failed and failure effect is set to hide\r\n                        this.remove();\r\n                    }\r\n                    else {\r\n                        // make changes to the svg\r\n                        (0,_svgUpdator__WEBPACK_IMPORTED_MODULE_5__["default"])(svgElement, finalData, attributes, status);\r\n                    }\r\n                }\r\n                catch (error) {\r\n                    console.error(`DavinciPics: ${error.message}`);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    delay = () => {\r\n        return new Promise((resolve) => {\r\n            setTimeout(() => {\r\n                resolve(true);\r\n            }, this.delayResponseTime);\r\n        });\r\n    };\r\n    clearInterval = () => {\r\n        clearInterval(this.interval);\r\n        this.style.opacity = "1";\r\n    };\r\n}\r\ncustomElements.define("davinci-pic", DavinciPic);\r\n\n\n//# sourceURL=webpack:///./src/index.ts?')},"./src/modules/attributeIntegrator.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/**\r\n * out of all the possible attributes of the element, it construct an object appropriate to the type of the entity\r\n * @param PicElement\r\n * @returns DavinciPicAttributes\r\n */\r\nconst integrateAttributes = (PicElement) => {\r\n    if (PicElement.offlineMode && !PicElement.dataPicUrl) {\r\n        throw new Error("Defining alternative picture url is necessary when using offline mode.");\r\n    }\r\n    switch (PicElement.type) {\r\n        case "token": {\r\n            const tokenAttrs = {\r\n                type: "token",\r\n                network: PicElement.network,\r\n                address: PicElement.address,\r\n                offlineMode: PicElement.offlineMode,\r\n                shape: PicElement.shape,\r\n                size: PicElement.size,\r\n                strokeWidth: PicElement.strokeWidth,\r\n                strokeColor: PicElement.strokeColor,\r\n                censor: PicElement.censor,\r\n                complexTokenType: PicElement.complexTokenType,\r\n                context: PicElement.context,\r\n                contextPosition: PicElement.contextPosition,\r\n                dataContextTitle: PicElement.dataContextTitle,\r\n                dataContextPicUrl: PicElement.dataContextPicUrl,\r\n                dataTitle: PicElement.dataTitle,\r\n                dataPicUrl: PicElement.dataPicUrl,\r\n                placeholder: PicElement.placeholder,\r\n                loadingEffect: PicElement.loadingEffect,\r\n                FailureEffect: PicElement.FailureEffect,\r\n                delayResponseTime: PicElement.delayResponseTime,\r\n            };\r\n            return tokenAttrs;\r\n        }\r\n        case "profile": {\r\n            const profileAttrs = {\r\n                type: "profile",\r\n                network: PicElement.network,\r\n                address: PicElement.address,\r\n                offlineMode: PicElement.offlineMode,\r\n                size: PicElement.size,\r\n                strokeWidth: PicElement.strokeWidth,\r\n                strokeColor: PicElement.strokeColor,\r\n                censor: PicElement.censor,\r\n                dataTitle: PicElement.dataTitle,\r\n                dataPicUrl: PicElement.dataPicUrl,\r\n                placeholder: PicElement.placeholder,\r\n                loadingEffect: PicElement.loadingEffect,\r\n                FailureEffect: PicElement.FailureEffect,\r\n                delayResponseTime: PicElement.delayResponseTime,\r\n                shape: PicElement.shape,\r\n            };\r\n            return profileAttrs;\r\n        }\r\n        case "banner": {\r\n            const bannerAttrs = {\r\n                type: "banner",\r\n                network: PicElement.network,\r\n                address: PicElement.address,\r\n                offlineMode: PicElement.offlineMode,\r\n                censor: PicElement.censor,\r\n                dataTitle: PicElement.dataTitle,\r\n                dataPicUrl: PicElement.dataPicUrl,\r\n                placeholder: PicElement.placeholder,\r\n                loadingEffect: PicElement.loadingEffect,\r\n                FailureEffect: PicElement.FailureEffect,\r\n                delayResponseTime: PicElement.delayResponseTime,\r\n            };\r\n            return bannerAttrs;\r\n        }\r\n        case "node": {\r\n            const nodeAttrs = {\r\n                type: "node",\r\n                network: PicElement.network,\r\n                address: PicElement.address,\r\n                offlineMode: PicElement.offlineMode,\r\n                size: PicElement.size,\r\n                shape: PicElement.shape,\r\n                strokeWidth: PicElement.strokeWidth,\r\n                strokeColor: PicElement.strokeColor,\r\n                censor: PicElement.censor,\r\n                dataTitle: PicElement.dataTitle,\r\n                dataPicUrl: PicElement.dataPicUrl,\r\n                placeholder: PicElement.placeholder,\r\n                loadingEffect: PicElement.loadingEffect,\r\n                FailureEffect: PicElement.FailureEffect,\r\n                delayResponseTime: PicElement.delayResponseTime,\r\n            };\r\n            return nodeAttrs;\r\n        }\r\n        case "network": {\r\n            const networksAttrs = {\r\n                type: "network",\r\n                network: PicElement.network,\r\n                offlineMode: PicElement.offlineMode,\r\n                size: PicElement.size,\r\n                shape: PicElement.shape,\r\n                strokeWidth: PicElement.strokeWidth,\r\n                strokeColor: PicElement.strokeColor,\r\n                censor: PicElement.censor,\r\n                dataTitle: PicElement.dataTitle,\r\n                dataPicUrl: PicElement.dataPicUrl,\r\n                placeholder: PicElement.placeholder,\r\n                loadingEffect: PicElement.loadingEffect,\r\n                FailureEffect: PicElement.FailureEffect,\r\n                delayResponseTime: PicElement.delayResponseTime,\r\n            };\r\n            return networksAttrs;\r\n        }\r\n        case "app": {\r\n            const appAttrs = {\r\n                type: "app",\r\n                name: PicElement.name,\r\n                offlineMode: PicElement.offlineMode,\r\n                size: PicElement.size,\r\n                shape: PicElement.shape,\r\n                strokeWidth: PicElement.strokeWidth,\r\n                strokeColor: PicElement.strokeColor,\r\n                censor: PicElement.censor,\r\n                dataTitle: PicElement.dataTitle,\r\n                dataPicUrl: PicElement.dataPicUrl,\r\n                placeholder: PicElement.placeholder,\r\n                loadingEffect: PicElement.loadingEffect,\r\n                FailureEffect: PicElement.FailureEffect,\r\n                delayResponseTime: PicElement.delayResponseTime,\r\n            };\r\n            return appAttrs;\r\n        }\r\n    }\r\n};\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (integrateAttributes);\r\n\n\n//# sourceURL=webpack:///./src/modules/attributeIntegrator.ts?')},"./src/modules/dataInitializer.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   getInitialPlaceholders: () => (/* binding */ getInitialPlaceholders)\n/* harmony export */ });\n/* harmony import */ var ___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! .. */ "./src/index.ts");\n/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./helpers */ "./src/modules/helpers.ts");\n\r\n\r\n/**\r\n * construct an object appropriate to the entity type in the form of expecting entity object from the API.\r\n * @param options attributes of the element\r\n * @param placeholders initial placeholder object\r\n * @returns\r\n */\r\nconst initializeData = (options, placeholders) => {\r\n    switch (options.type) {\r\n        case "token": {\r\n            let initialData = {\r\n                type: "TOKEN",\r\n                address: options.address,\r\n                supportingBackgroundColor: getPlaceholderBgColor(placeholders),\r\n                network: {\r\n                    id: options.network,\r\n                    title: options.context === "network" ? options.dataContextTitle || "" : "",\r\n                    pic: "",\r\n                    supportingBackgroundColor: placeholders.color,\r\n                },\r\n            };\r\n            const urlContainsLpSign = options.dataPicUrl?.includes("|");\r\n            const titleContainsLpSign = options.dataTitle?.includes("|");\r\n            // send back an lp token entity\r\n            if (options.complexTokenType === "lp" || urlContainsLpSign || titleContainsLpSign) {\r\n                let token0Pic = placeholders.url, token1Pic = placeholders.url, token0Title = "", token1Title = "";\r\n                if (titleContainsLpSign && options.dataTitle) {\r\n                    const titles = options.dataTitle.split("|");\r\n                    token0Title = titles[0];\r\n                    token1Title = titles[1];\r\n                }\r\n                return {\r\n                    ...initialData,\r\n                    type: "LP",\r\n                    title: "",\r\n                    sensitivity: "safe",\r\n                    token0: {\r\n                        network: options.network,\r\n                        address: options.address,\r\n                        sensitivity: "safe",\r\n                        pic: token0Pic,\r\n                        supportingBackgroundColor: getPlaceholderBgColor(placeholders),\r\n                        title: token0Title,\r\n                    },\r\n                    token1: {\r\n                        network: options.network,\r\n                        address: options.address,\r\n                        sensitivity: "safe",\r\n                        pic: token1Pic,\r\n                        supportingBackgroundColor: getPlaceholderBgColor(placeholders),\r\n                        title: token1Title,\r\n                    },\r\n                    app: getInitialAppData(options, placeholders),\r\n                };\r\n            }\r\n            // send back a wrapped token entity\r\n            if (options.complexTokenType === "wrapped") {\r\n                return {\r\n                    ...initialData,\r\n                    type: "WRAPPED",\r\n                    title: "",\r\n                    sensitivity: "safe",\r\n                    originalToken: {\r\n                        network: options.network,\r\n                        address: options.address,\r\n                        sensitivity: "safe",\r\n                        pic: placeholders.url,\r\n                        supportingBackgroundColor: getPlaceholderBgColor(placeholders),\r\n                        title: options.dataTitle || "",\r\n                    },\r\n                    app: getInitialAppData(options, placeholders),\r\n                };\r\n            }\r\n            // send back a normal token entity\r\n            return {\r\n                ...initialData,\r\n                title: options.dataTitle || "",\r\n                pic: placeholders.url,\r\n                supportingBackgroundColor: getPlaceholderBgColor(placeholders),\r\n            };\r\n        }\r\n        case "profile":\r\n            return {\r\n                network: options.network,\r\n                address: options.address,\r\n                title: options.dataTitle || "",\r\n                sensitivity: "safe",\r\n                pic: placeholders.url,\r\n                supportingBackgroundColor: getPlaceholderBgColor(placeholders),\r\n            };\r\n        case "banner":\r\n            return {\r\n                network: options.network,\r\n                address: options.address,\r\n                title: options.dataTitle || "",\r\n                sensitivity: "safe",\r\n                banner: placeholders.url,\r\n                supportingBackgroundColor: getPlaceholderBgColor(placeholders),\r\n            };\r\n        case "node":\r\n            return {\r\n                network: options.network,\r\n                address: options.address,\r\n                title: options.dataTitle || "",\r\n                supportingBackgroundColor: getPlaceholderBgColor(placeholders),\r\n                pic: placeholders.url,\r\n            };\r\n        case "network":\r\n            return {\r\n                id: options.network,\r\n                title: options.dataTitle || "",\r\n                pic: placeholders.url,\r\n                supportingBackgroundColor: getPlaceholderBgColor(placeholders),\r\n            };\r\n        case "app":\r\n            return {\r\n                name: " ",\r\n                title: options.dataTitle || "",\r\n                pic: placeholders.url,\r\n                supportingBackgroundColor: getPlaceholderBgColor(placeholders),\r\n            };\r\n    }\r\n};\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (initializeData);\r\nconst getInitialPlaceholders = (text, type) => {\r\n    const placeholders = { color: "transparent", url: "" };\r\n    if (text === "transparent") {\r\n        return placeholders;\r\n    }\r\n    if (text.endsWith("randomColor") || text.endsWith("randomColor\'")) {\r\n        placeholders.color = (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.getRandomColor)();\r\n        return placeholders;\r\n    }\r\n    let possbileBgColor = text.match(___WEBPACK_IMPORTED_MODULE_0__.davinciPicsConfig.colorRegex);\r\n    if (possbileBgColor) {\r\n        placeholders.color = possbileBgColor[0];\r\n        return placeholders;\r\n    }\r\n    placeholders.url = (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.getMissingURL)(type, text);\r\n    return placeholders;\r\n};\r\nconst getInitialAppData = (options, placeholders) => {\r\n    return {\r\n        title: options.dataContextTitle || "",\r\n        pic: "",\r\n        supportingBackgroundColor: placeholders.color,\r\n    };\r\n};\r\nconst getPlaceholderBgColor = (placeholders) => {\r\n    return !placeholders.url ? placeholders.color : "transparent";\r\n};\r\n\n\n//# sourceURL=webpack:///./src/modules/dataInitializer.ts?')},"./src/modules/dataLoader.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var ___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! .. */ "./src/index.ts");\n\r\n/**\r\n * sends the get request to the API and return the approprite entity data.\r\n * in case of not found an the API it returns an empty object with status of 200, which is expected\r\n * @param attributes\r\n * @returns\r\n */\r\nconst davinciPicsLoad = async (attributes) => {\r\n    if (attributes.offlineMode !== true) {\r\n        let url = attributes.type === "network"\r\n            ? `${___WEBPACK_IMPORTED_MODULE_0__.davinciPicsConfig.apiUrl}/networks/${attributes.network}`\r\n            : attributes.type === "app"\r\n                ? `${___WEBPACK_IMPORTED_MODULE_0__.davinciPicsConfig.apiUrl}/apps/${attributes.name}`\r\n                : `${___WEBPACK_IMPORTED_MODULE_0__.davinciPicsConfig.apiUrl}/${attributes.type === "banner" || attributes.type === "profile" ? "account" : attributes.type}s/${attributes.network}/${attributes.address}`;\r\n        try {\r\n            const response = await fetch(url);\r\n            // Check for HTTP errors\r\n            if (!response.ok) {\r\n                throw new Error(`HTTP error! status: ${response.status}`);\r\n            }\r\n            // Parse JSON response\r\n            const data = (await response.json());\r\n            return data;\r\n        }\r\n        catch (error) {\r\n            console.error(`DavinciPic Fetch Error: ${error.message}`);\r\n        }\r\n    }\r\n    return {};\r\n};\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (davinciPicsLoad);\r\n\n\n//# sourceURL=webpack:///./src/modules/dataLoader.ts?')},"./src/modules/helpers.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getContextData: () => (/* binding */ getContextData),\n/* harmony export */   getMissingURL: () => (/* binding */ getMissingURL),\n/* harmony export */   getRandomColor: () => (/* binding */ getRandomColor),\n/* harmony export */   getShapeRadius: () => (/* binding */ getShapeRadius),\n/* harmony export */   mustBeCensored: () => (/* binding */ mustBeCensored)\n/* harmony export */ });\nconst defaultPlaceholderPictures = {\r\n    token: {\r\n        defaultBright: "https://arweave.net/ZAMK4tuU1MZ9TkNl2ARV2QDRumGT5Yxw13uCpW3kX6w",\r\n        default: "https://arweave.net/wW4bp6129XobnasaZbDB4RxdnpipGR8XyK0tUXGiVL0",\r\n        defaultDark: "https://arweave.net/j5B7_CYAOdrk6YJNVeJMeOHn4HbySsgkObUSfpvUuDA",\r\n        questionMarkBright: "https://arweave.net/z-5G9bNj_gisiQhVECwaUdSzuXMxl9Gi9UxYqrwUrq4",\r\n        questionMark: "https://arweave.net/u9t3--97iFNeFB4XaX7auIdcJWjNWF090BFcJdnBmiQ",\r\n        questionMarkDark: "https://arweave.net/HDVERv0ghkA91qhI2ud7qVUU_FFtAIyYELHHxQ9t2BQ",\r\n        exclamationMarkBight: "https://arweave.net/HS0RGj5YSKgcNch2US1E8saZKdM8RGlQWpxwhk5eKrk",\r\n        exclamationMark: "https://arweave.net/KwbKX4FOOM59KmFrAvtRhr5U-8MqWsSzU0rSA3Z7Z4A",\r\n        exclamationMarkDark: "https://arweave.net/A3Ja0tV3kU6EhVvN1EQejG-kmtY_yEcbgQ6pShYRXHo",\r\n    },\r\n    profile: {\r\n        defaultBright: "https://arweave.net/WxLlax6NBCapLUuKcuy-wvLlKLBTqxTV40yJt7Yc26Q",\r\n        default: "https://arweave.net/qsn_zIlG_7_Ob4_qS6Bpc8vLEc5bPScw6JMly_shxlk",\r\n        defaultDark: "https://arweave.net/ZHWeQz5R6VHBHOg6eOGekMsudTyy7uNBdnrul5gIIu0",\r\n    },\r\n};\r\nconst colors = [\r\n    "#ef4444",\r\n    "#f97316",\r\n    "#f59e0b",\r\n    "#eab308",\r\n    "#84cc16",\r\n    "#22c55e",\r\n    "#10b981",\r\n    "#14b8a6",\r\n    "#06b6d4",\r\n    "#0ea5e9",\r\n    "#3b82f6",\r\n    "#6366f1",\r\n    "#8b5cf6",\r\n    "#a855f7",\r\n    "#d946ef",\r\n    "#ec4899",\r\n    "#f43f5e",\r\n];\r\n// extracts the url from a string which contains one in the format of url(...) or url(\'\')\r\nfunction getMissingURL(type, placeholder) {\r\n    placeholder = placeholder || "defaultBright";\r\n    // Check if it\'s a URL in the format url() or url(\'\')\r\n    const urlMatch = placeholder.match(/url\\([\'"]?(.*?)[\'"]?\\)/);\r\n    if (urlMatch) {\r\n        return urlMatch[1]; // Return the extracted URL\r\n    }\r\n    // banners has no default pictures\r\n    if (type === "banner")\r\n        return "";\r\n    // Check if it\'s one of the known classes\r\n    const knownURL = defaultPlaceholderPictures[type === "profile" ? "profile" : "token"][placeholder];\r\n    if (knownURL) {\r\n        return knownURL; // Return the known URL\r\n    }\r\n    // Default to \'defaultBright\'\r\n    return defaultPlaceholderPictures[type === "profile" ? "profile" : "token"]["defaultBright"];\r\n}\r\n// cheks the sensetivity of entity and the expected sensoring type of the element and act upon it\r\nconst mustBeCensored = (censoredType, checkingType) => {\r\n    if (checkingType === undefined || censoredType === undefined)\r\n        return false;\r\n    censoredType = censoredType?.toUpperCase();\r\n    checkingType = checkingType?.toUpperCase();\r\n    if (checkingType === "SAFE")\r\n        return false;\r\n    if (checkingType === "SENSITIVE" && (censoredType === "INAPPROPRIATE" || censoredType === "COPYRIGHT-VIOLATED"))\r\n        return false;\r\n    if (checkingType === "INAPPROPRIATE" && censoredType === "COPYRIGHT-VIOLATED")\r\n        return false;\r\n    return true;\r\n};\r\nfunction getRandomColor() {\r\n    const randomIndex = Math.floor(Math.random() * colors.length);\r\n    return colors[randomIndex];\r\n}\r\nfunction getShapeRadius(shape, size = 100) {\r\n    if (!shape)\r\n        shape = "circle";\r\n    return String(shape === "circle" ? size / 2 : shape === "smoothSquare" ? size * (15 / 100) : 0);\r\n}\r\n// normalize the wrapped or liquidity token\'s context(app or network) data\r\nconst getContextData = (options, data) => {\r\n    if (options.context === "app" && data?.app) {\r\n        return {\r\n            type: "app",\r\n            pic: data.app.pic || "",\r\n            title: data.app.title ? `Originated by ${data.app.title}` : "",\r\n            supportingBackgroundColor: data.app.supportingBackgroundColor || "transparent",\r\n        };\r\n    }\r\n    if (options.context === "network" && data?.network) {\r\n        return {\r\n            type: "network",\r\n            pic: data.network.pic || "",\r\n            title: data.network.title ? `Originated on ${data.network.title}` : "",\r\n            supportingBackgroundColor: data.network.supportingBackgroundColor || "transparent",\r\n        };\r\n    }\r\n    return { type: "none", pic: "", title: "", supportingBackgroundColor: "transparent" };\r\n};\r\n\n\n//# sourceURL=webpack:///./src/modules/helpers.ts?')},"./src/svgGenerator/banner.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var ___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! .. */ "./src/index.ts");\n/* harmony import */ var _templates_bannerSVG__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../templates/bannerSVG */ "./src/templates/bannerSVG.ts");\n\r\n\r\n// reads the banner template and add the inital data to it\r\nconst generateBannerSvg = (data) => {\r\n    const uniqueID = `banner-${++___WEBPACK_IMPORTED_MODULE_0__.davinciPicsConfig.counter}`;\r\n    // combine the svg template with the data\r\n    const clonedSvg = document.importNode(_templates_bannerSVG__WEBPACK_IMPORTED_MODULE_1__["default"].content, true);\r\n    const svg = clonedSvg.querySelector("svg");\r\n    if (svg) {\r\n        svg.setAttribute("data-unique-id", uniqueID);\r\n        const rectPathElem = clonedSvg.querySelector("clipPath");\r\n        if (rectPathElem)\r\n            rectPathElem.id = `shape-${uniqueID}`;\r\n        const BgElem = clonedSvg.querySelector("#rect-bg");\r\n        if (BgElem) {\r\n            BgElem.setAttribute("fill", data.supportingBackgroundColor || "transparent");\r\n        }\r\n        const imageElem = clonedSvg.querySelector("image");\r\n        if (imageElem) {\r\n            imageElem.setAttribute("href", data.banner || "");\r\n            imageElem.setAttribute("clip-path", `url(#shape-${uniqueID})`);\r\n        }\r\n    }\r\n    return svg;\r\n};\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (generateBannerSvg);\r\n\n\n//# sourceURL=webpack:///./src/svgGenerator/banner.ts?')},"./src/svgGenerator/base.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var ___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! .. */ "./src/index.ts");\n/* harmony import */ var _templates_baseSVG__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../templates/baseSVG */ "./src/templates/baseSVG.ts");\n\r\n\r\n// reads the base template and add the inital data to it\r\nconst generateBaseSvg = (title, pictureUrl, supportingBackgroundColor, options) => {\r\n    const uniqueID = `${++___WEBPACK_IMPORTED_MODULE_0__.davinciPicsConfig.counter}`;\r\n    const strokeWidth = options.strokeWidth || 0;\r\n    // cloning the svg template\r\n    const clonedSvg = document.importNode(_templates_baseSVG__WEBPACK_IMPORTED_MODULE_1__["default"].content, true);\r\n    const svg = clonedSvg.querySelector("svg");\r\n    if (svg) {\r\n        svg.setAttribute("width", `${options.size}`);\r\n        svg.setAttribute("height", `${options.size}`);\r\n        svg.setAttribute("data-unique-id", uniqueID);\r\n        svg.setAttribute("data-template-type", "base");\r\n        (0,_templates_baseSVG__WEBPACK_IMPORTED_MODULE_1__.setBasePathRect)(clonedSvg, uniqueID, strokeWidth, options.shape);\r\n        (0,_templates_baseSVG__WEBPACK_IMPORTED_MODULE_1__.setBaseBgRect)(clonedSvg, supportingBackgroundColor, strokeWidth, options.shape);\r\n        (0,_templates_baseSVG__WEBPACK_IMPORTED_MODULE_1__.setBaseImage)(clonedSvg, pictureUrl, uniqueID, strokeWidth);\r\n        (0,_templates_baseSVG__WEBPACK_IMPORTED_MODULE_1__.setBaseRect)(clonedSvg, title, strokeWidth, options, false);\r\n    }\r\n    return svg;\r\n};\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (generateBaseSvg);\r\n\n\n//# sourceURL=webpack:///./src/svgGenerator/base.ts?')},"./src/svgGenerator/contextual.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var ___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! .. */ "./src/index.ts");\n/* harmony import */ var _templates_contextualTokenSVG__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../templates/contextualTokenSVG */ "./src/templates/contextualTokenSVG.ts");\n\r\n\r\n// reads the contextual template and add the inital data to it\r\nconst generateContextualTokenSvg = (title, pictureUrl, contextTitle, contextPictureUrl, supportingBackgroundColor, contextSupportingBackgroundColor, options) => {\r\n    const strokeWidth = options.strokeWidth || 0;\r\n    const uniqueID = `${++___WEBPACK_IMPORTED_MODULE_0__.davinciPicsConfig.counter}`;\r\n    const tokenCircleData = (0,_templates_contextualTokenSVG__WEBPACK_IMPORTED_MODULE_1__.getContextualTokenShapeData)();\r\n    const contextCircleData = (0,_templates_contextualTokenSVG__WEBPACK_IMPORTED_MODULE_1__.getContextualContextShapeData)(options, tokenCircleData, strokeWidth);\r\n    // combine the svg template with the data\r\n    const clonedSvg = document.importNode(_templates_contextualTokenSVG__WEBPACK_IMPORTED_MODULE_1__["default"].content, true);\r\n    const svg = clonedSvg.querySelector("svg");\r\n    if (svg) {\r\n        svg.setAttribute("width", `${options.size}`);\r\n        svg.setAttribute("height", `${options.size}`);\r\n        svg.setAttribute("data-unique-id", uniqueID);\r\n        svg.setAttribute("data-template-type", "contextual");\r\n        (0,_templates_contextualTokenSVG__WEBPACK_IMPORTED_MODULE_1__.setContextualPath)(clonedSvg, uniqueID, tokenCircleData, contextCircleData);\r\n        (0,_templates_contextualTokenSVG__WEBPACK_IMPORTED_MODULE_1__.setContextualTokenShapes)(clonedSvg, uniqueID, tokenCircleData, false, pictureUrl, title, supportingBackgroundColor, strokeWidth, options.strokeColor || "", false);\r\n        if (options.context && options.context !== "none") {\r\n            (0,_templates_contextualTokenSVG__WEBPACK_IMPORTED_MODULE_1__.setContextualContextShape)(clonedSvg, uniqueID, contextCircleData, contextPictureUrl, contextTitle, contextSupportingBackgroundColor, strokeWidth, options.strokeColor || "", false);\r\n        }\r\n    }\r\n    return svg;\r\n};\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (generateContextualTokenSvg);\r\n\n\n//# sourceURL=webpack:///./src/svgGenerator/contextual.ts?')},"./src/svgGenerator/index.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _modules_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../modules/helpers */ "./src/modules/helpers.ts");\n/* harmony import */ var _types_guards__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../types/guards */ "./src/types/guards.ts");\n/* harmony import */ var _banner__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./banner */ "./src/svgGenerator/banner.ts");\n/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./base */ "./src/svgGenerator/base.ts");\n/* harmony import */ var _contextual__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./contextual */ "./src/svgGenerator/contextual.ts");\n/* harmony import */ var _lp__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./lp */ "./src/svgGenerator/lp.ts");\n\r\n\r\n\r\n\r\n\r\n\r\nconst generateSvg = (data, options) => {\r\n    if (options.type === "token") {\r\n        if ((0,_types_guards__WEBPACK_IMPORTED_MODULE_1__.isLpTokenEntity)(data)) {\r\n            return (0,_lp__WEBPACK_IMPORTED_MODULE_5__["default"])(data, options);\r\n        }\r\n        if ((0,_types_guards__WEBPACK_IMPORTED_MODULE_1__.isWrappedTokenEntity)(data)) {\r\n            const contextData = (0,_modules_helpers__WEBPACK_IMPORTED_MODULE_0__.getContextData)(options, data);\r\n            return (0,_contextual__WEBPACK_IMPORTED_MODULE_4__["default"])(data.title, data.originalToken.pic, contextData.title, contextData.pic, data.originalToken.supportingBackgroundColor, contextData.supportingBackgroundColor, options);\r\n        }\r\n        if ((0,_types_guards__WEBPACK_IMPORTED_MODULE_1__.isTokenEntity)(data)) {\r\n            if (options.context === "network") {\r\n                return (0,_contextual__WEBPACK_IMPORTED_MODULE_4__["default"])(data.title, data.pic, data.network.title, data.network.pic, data.supportingBackgroundColor, data.network.supportingBackgroundColor, options);\r\n            }\r\n            return (0,_base__WEBPACK_IMPORTED_MODULE_3__["default"])(data.title, data.pic, data.supportingBackgroundColor, options);\r\n        }\r\n    }\r\n    if (options.type === "profile" && (0,_types_guards__WEBPACK_IMPORTED_MODULE_1__.isProfileEntity)(data)) {\r\n        // return generateProfileSvg(data, options);\r\n        return (0,_base__WEBPACK_IMPORTED_MODULE_3__["default"])(data.title, data.pic, data.supportingBackgroundColor, options);\r\n    }\r\n    if (options.type === "banner" && (0,_types_guards__WEBPACK_IMPORTED_MODULE_1__.isBannerEntity)(data)) {\r\n        return (0,_banner__WEBPACK_IMPORTED_MODULE_2__["default"])(data);\r\n    }\r\n    if (options.type === "node" && (0,_types_guards__WEBPACK_IMPORTED_MODULE_1__.isNodeEntity)(data)) {\r\n        return (0,_base__WEBPACK_IMPORTED_MODULE_3__["default"])(data.title, data.pic, data.supportingBackgroundColor, options);\r\n    }\r\n    if (options.type === "network" && (0,_types_guards__WEBPACK_IMPORTED_MODULE_1__.isNetworkEntity)(data)) {\r\n        return (0,_base__WEBPACK_IMPORTED_MODULE_3__["default"])(data.title, data.pic, data.supportingBackgroundColor, options);\r\n    }\r\n    if (options.type === "app" && (0,_types_guards__WEBPACK_IMPORTED_MODULE_1__.isAppEntity)(data)) {\r\n        return (0,_base__WEBPACK_IMPORTED_MODULE_3__["default"])(data.title, data.pic, data.supportingBackgroundColor, options);\r\n    }\r\n    throw new Error("svg couldn\'t be generated.");\r\n};\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (generateSvg);\r\n\n\n//# sourceURL=webpack:///./src/svgGenerator/index.ts?')},"./src/svgGenerator/lp.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var ___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! .. */ "./src/index.ts");\n/* harmony import */ var _modules_helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../modules/helpers */ "./src/modules/helpers.ts");\n/* harmony import */ var _templates_LPTokenSVG__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../templates/LPTokenSVG */ "./src/templates/LPTokenSVG.ts");\n\r\n\r\n\r\n// reads the lp template and add the inital data to it\r\nconst generateLpTokenSvg = (data, options) => {\r\n    const strokeWidth = options.strokeWidth || 0;\r\n    const uniqueID = `lp-${++___WEBPACK_IMPORTED_MODULE_0__.davinciPicsConfig.counter}`;\r\n    const token0CircleData = (0,_templates_LPTokenSVG__WEBPACK_IMPORTED_MODULE_2__.getLpToken0CircleData)();\r\n    const token1CircleData = (0,_templates_LPTokenSVG__WEBPACK_IMPORTED_MODULE_2__.getLpToken1CircleData)();\r\n    const contextCircleData = (0,_templates_LPTokenSVG__WEBPACK_IMPORTED_MODULE_2__.getLpTokenContextData)(options, token0CircleData, token1CircleData, strokeWidth);\r\n    const contextData = (0,_modules_helpers__WEBPACK_IMPORTED_MODULE_1__.getContextData)(options, data);\r\n    // clone the template\r\n    const clonedSvg = document.importNode(_templates_LPTokenSVG__WEBPACK_IMPORTED_MODULE_2__["default"].content, true);\r\n    const svg = clonedSvg.querySelector("svg");\r\n    if (svg) {\r\n        svg.setAttribute("width", `${options.size}`);\r\n        svg.setAttribute("height", `${options.size}`);\r\n        svg.setAttribute("data-unique-id", uniqueID);\r\n        svg.setAttribute("data-template-type", "lp");\r\n        (0,_templates_LPTokenSVG__WEBPACK_IMPORTED_MODULE_2__.setLpPath)(clonedSvg, uniqueID, token0CircleData, token1CircleData, contextCircleData);\r\n        (0,_templates_LPTokenSVG__WEBPACK_IMPORTED_MODULE_2__.setLpTokenShapes)(clonedSvg, uniqueID, token0CircleData, token1CircleData, false, false, data, options.strokeColor || "", strokeWidth, false);\r\n        // context\r\n        if (contextData.type !== "none") {\r\n            (0,_templates_LPTokenSVG__WEBPACK_IMPORTED_MODULE_2__.setLpContextShapes)(clonedSvg, uniqueID, contextCircleData, contextData, options.strokeColor || "", strokeWidth, false);\r\n        }\r\n    }\r\n    return svg;\r\n};\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (generateLpTokenSvg);\r\n\n\n//# sourceURL=webpack:///./src/svgGenerator/lp.ts?')},"./src/svgUpdator/banner.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _modules_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../modules/helpers */ "./src/modules/helpers.ts");\n\r\n// update the banner elements with final data\r\nconst updateBannerSvg = (svg, data, options) => {\r\n    const mustPictureBeCensored = (0,_modules_helpers__WEBPACK_IMPORTED_MODULE_0__.mustBeCensored)(options.censor, data?.sensitivity);\r\n    if (svg) {\r\n        const uniqueID = svg.getAttribute("data-unique-id");\r\n        const filterElem = svg.querySelector("filter");\r\n        if (filterElem && mustPictureBeCensored) {\r\n            filterElem.id = `blur-${uniqueID}`;\r\n        }\r\n        else {\r\n            filterElem?.remove();\r\n        }\r\n        const BgElem = svg.querySelector("#rect-bg");\r\n        if (BgElem) {\r\n            BgElem.setAttribute("fill", data.supportingBackgroundColor || "transparent");\r\n        }\r\n        const imageElem = svg.querySelector("image");\r\n        if (imageElem) {\r\n            imageElem.setAttribute("href", data.banner || "");\r\n            if (mustPictureBeCensored)\r\n                imageElem.setAttribute("filter", `url(#blur-${uniqueID})`);\r\n        }\r\n    }\r\n};\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (updateBannerSvg);\r\n\n\n//# sourceURL=webpack:///./src/svgUpdator/banner.ts?')},"./src/svgUpdator/base.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _modules_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../modules/helpers */ "./src/modules/helpers.ts");\n/* harmony import */ var _templates_baseSVG__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../templates/baseSVG */ "./src/templates/baseSVG.ts");\n\r\n\r\n// update the base elements with final data\r\nconst updateBaseSvg = (initialSvg, title, pictureUrl, supportingBackgroundColor, sensitivity, options, status) => {\r\n    const uniqueID = initialSvg.getAttribute("data-unique-id");\r\n    const strokeWidth = options.strokeWidth || 0;\r\n    const mustPictureBeCensored = (0,_modules_helpers__WEBPACK_IMPORTED_MODULE_0__.mustBeCensored)(options.censor, sensitivity);\r\n    // when the wrong template is generated for loading phase, generate the svg again with the right template\r\n    if (initialSvg?.getAttribute("data-template-type") !== "base") {\r\n        // cloning the svg template\r\n        const clonedSvg = document.importNode(_templates_baseSVG__WEBPACK_IMPORTED_MODULE_1__["default"].content, true);\r\n        const svg = clonedSvg.querySelector("svg");\r\n        if (svg) {\r\n            initialSvg.replaceWith(svg);\r\n            (0,_templates_baseSVG__WEBPACK_IMPORTED_MODULE_1__.setBasePathRect)(svg, uniqueID, strokeWidth, options.shape);\r\n            (0,_templates_baseSVG__WEBPACK_IMPORTED_MODULE_1__.setBaseFilter)(svg, mustPictureBeCensored, uniqueID);\r\n            (0,_templates_baseSVG__WEBPACK_IMPORTED_MODULE_1__.setBaseBgRect)(svg, supportingBackgroundColor, strokeWidth, options.shape);\r\n            (0,_templates_baseSVG__WEBPACK_IMPORTED_MODULE_1__.setBaseImage)(svg, pictureUrl, uniqueID, strokeWidth);\r\n            (0,_templates_baseSVG__WEBPACK_IMPORTED_MODULE_1__.setBaseRect)(svg, title, strokeWidth, options, true);\r\n        }\r\n        return;\r\n    }\r\n    // since right template is generated during the loading phase, continue with updating the elements\r\n    if (initialSvg) {\r\n        (0,_templates_baseSVG__WEBPACK_IMPORTED_MODULE_1__.setBaseFilter)(initialSvg, mustPictureBeCensored, uniqueID);\r\n        const bgColorElem = initialSvg.querySelector(`#bg-color`);\r\n        if (bgColorElem) {\r\n            bgColorElem.setAttribute("fill", supportingBackgroundColor || "transparent");\r\n        }\r\n        const imageElem = initialSvg.querySelector("image");\r\n        if (imageElem) {\r\n            imageElem.setAttribute("href", pictureUrl);\r\n            if (mustPictureBeCensored)\r\n                imageElem.setAttribute("filter", `url(#blur-${uniqueID})`);\r\n        }\r\n        const rectElem = imageElem?.nextElementSibling;\r\n        if (rectElem) {\r\n            if (status === "success")\r\n                rectElem.setAttribute("stroke-width", String(strokeWidth));\r\n            if (!mustPictureBeCensored) {\r\n                const mainTitleElem = rectElem.firstElementChild;\r\n                if (mainTitleElem)\r\n                    mainTitleElem.textContent = title;\r\n            }\r\n        }\r\n    }\r\n};\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (updateBaseSvg);\r\n\n\n//# sourceURL=webpack:///./src/svgUpdator/base.ts?')},"./src/svgUpdator/contextual.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _modules_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../modules/helpers */ "./src/modules/helpers.ts");\n/* harmony import */ var _templates_contextualTokenSVG__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../templates/contextualTokenSVG */ "./src/templates/contextualTokenSVG.ts");\n\r\n\r\n/**\r\n * update the wrapped or contextual token elements with final data, there is two case in wrapped tokens because the element\'s inital template is the base template\r\n * but when the API specifies that it must be wrapped, we must reconstruct it\r\n * in the case when the element has a complex-token-type of wrapped, the template is correct and it will be updated\r\n */\r\nconst updateContextualTokenSvg = (initialSvg, title, pictureUrl, contextTitle, contextPictureUrl, sensitivity, supportingBackgroundColor, contextSupportingBackgroundColor, options, status) => {\r\n    const uniqueID = initialSvg.getAttribute("data-unique-id");\r\n    const strokeWidth = options.strokeWidth || 0;\r\n    const mustPictureBeCensored = (0,_modules_helpers__WEBPACK_IMPORTED_MODULE_0__.mustBeCensored)(options.censor, sensitivity);\r\n    if (initialSvg && initialSvg?.getAttribute("data-template-type") === "contextual") {\r\n        (0,_templates_contextualTokenSVG__WEBPACK_IMPORTED_MODULE_1__.setContextualFilter)(initialSvg, uniqueID, mustPictureBeCensored);\r\n        const bgElem = initialSvg.querySelector("#contextual-bg-circle");\r\n        bgElem?.setAttribute("fill", supportingBackgroundColor || "transparent");\r\n        const imageElem = initialSvg.querySelector("#contextual-image");\r\n        if (imageElem) {\r\n            imageElem.setAttribute("href", pictureUrl);\r\n            if (mustPictureBeCensored) {\r\n                imageElem.setAttribute("filter", `url(#contextual-blur-${uniqueID})`);\r\n            }\r\n        }\r\n        const tokenCircleElem = initialSvg.querySelector("#contextual-circle");\r\n        if (tokenCircleElem) {\r\n            if (status === "success")\r\n                tokenCircleElem.setAttribute("stroke-width", `${strokeWidth}`);\r\n            if (!mustPictureBeCensored) {\r\n                const mainTitleElem = tokenCircleElem.firstElementChild;\r\n                if (mainTitleElem)\r\n                    mainTitleElem.textContent = title || "";\r\n            }\r\n        }\r\n        const contextImageElem = initialSvg.querySelector("#context-image");\r\n        const contextCircleElem = initialSvg.querySelector("#context-circle");\r\n        if (contextImageElem && contextCircleElem && options.context !== "none") {\r\n            const contextBgElem = initialSvg.querySelector("#context-bg-circle");\r\n            contextBgElem?.setAttribute("fill", contextSupportingBackgroundColor || "transparent");\r\n            contextImageElem.setAttribute("href", contextPictureUrl || "");\r\n            if (contextPictureUrl && status === "success")\r\n                contextCircleElem.setAttribute("stroke-width", `${strokeWidth}`);\r\n            contextCircleElem.setAttribute("fill", "transparent");\r\n            const contextTitleElem = contextCircleElem.firstElementChild;\r\n            if (contextTitleElem)\r\n                contextTitleElem.textContent = contextTitle || "";\r\n        }\r\n        return;\r\n    }\r\n    const tokenCircleData = (0,_templates_contextualTokenSVG__WEBPACK_IMPORTED_MODULE_1__.getContextualTokenShapeData)();\r\n    const contextCircleData = (0,_templates_contextualTokenSVG__WEBPACK_IMPORTED_MODULE_1__.getContextualContextShapeData)(options, tokenCircleData, strokeWidth);\r\n    // combine the svg template with the data\r\n    const clonedSvg = document.importNode(_templates_contextualTokenSVG__WEBPACK_IMPORTED_MODULE_1__["default"].content, true);\r\n    const svg = clonedSvg.querySelector("svg");\r\n    if (initialSvg && svg) {\r\n        initialSvg.replaceWith(svg);\r\n        (0,_templates_contextualTokenSVG__WEBPACK_IMPORTED_MODULE_1__.setContextualPath)(svg, uniqueID, tokenCircleData, contextCircleData);\r\n        (0,_templates_contextualTokenSVG__WEBPACK_IMPORTED_MODULE_1__.setContextualFilter)(svg, uniqueID, mustPictureBeCensored);\r\n        (0,_templates_contextualTokenSVG__WEBPACK_IMPORTED_MODULE_1__.setContextualTokenShapes)(svg, uniqueID, tokenCircleData, mustPictureBeCensored, pictureUrl, title, supportingBackgroundColor, strokeWidth, options.strokeColor || "", true);\r\n        if (options.context && options.context !== "none") {\r\n            (0,_templates_contextualTokenSVG__WEBPACK_IMPORTED_MODULE_1__.setContextualContextShape)(svg, uniqueID, contextCircleData, contextPictureUrl, contextTitle, contextSupportingBackgroundColor, strokeWidth, options.strokeColor || "", true);\r\n        }\r\n    }\r\n};\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (updateContextualTokenSvg);\r\n\n\n//# sourceURL=webpack:///./src/svgUpdator/contextual.ts?')},"./src/svgUpdator/index.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _modules_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../modules/helpers */ "./src/modules/helpers.ts");\n/* harmony import */ var _types_guards__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../types/guards */ "./src/types/guards.ts");\n/* harmony import */ var _banner__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./banner */ "./src/svgUpdator/banner.ts");\n/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./base */ "./src/svgUpdator/base.ts");\n/* harmony import */ var _contextual__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./contextual */ "./src/svgUpdator/contextual.ts");\n/* harmony import */ var _lp__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./lp */ "./src/svgUpdator/lp.ts");\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * updates or might regenerate the svg element with the final data\r\n * @param svg the inital generated svg element\r\n * @param data the final data\r\n * @param options attributes object\r\n * @param status was the finalizing data was successful or failed\r\n * @returns\r\n */\r\nconst updateSvg = (svg, data, options, status) => {\r\n    svg.style.display = "inline";\r\n    if (options.type === "token") {\r\n        if ((0,_types_guards__WEBPACK_IMPORTED_MODULE_1__.isLpTokenEntity)(data)) {\r\n            return (0,_lp__WEBPACK_IMPORTED_MODULE_5__["default"])(svg, data, options, status);\r\n        }\r\n        if ((0,_types_guards__WEBPACK_IMPORTED_MODULE_1__.isWrappedTokenEntity)(data)) {\r\n            const contextData = (0,_modules_helpers__WEBPACK_IMPORTED_MODULE_0__.getContextData)(options, data);\r\n            return (0,_contextual__WEBPACK_IMPORTED_MODULE_4__["default"])(svg, data.title, data.originalToken.pic, contextData.title, contextData.pic, data.originalToken.sensitivity, data.originalToken.supportingBackgroundColor, contextData.supportingBackgroundColor, options, status);\r\n        }\r\n        if ((0,_types_guards__WEBPACK_IMPORTED_MODULE_1__.isTokenEntity)(data)) {\r\n            if (options.context === "network") {\r\n                return (0,_contextual__WEBPACK_IMPORTED_MODULE_4__["default"])(svg, data.title, data.pic, data.network.title, data.network.pic, data.sensitivity, data.supportingBackgroundColor, data.network.supportingBackgroundColor, options, status);\r\n            }\r\n            return (0,_base__WEBPACK_IMPORTED_MODULE_3__["default"])(svg, data.title, data.pic, data.supportingBackgroundColor, data.sensitivity, options, status);\r\n        }\r\n    }\r\n    if (options.type === "profile" && (0,_types_guards__WEBPACK_IMPORTED_MODULE_1__.isProfileEntity)(data)) {\r\n        // return updateProfileSvg(svg, data, options, status);\r\n        return (0,_base__WEBPACK_IMPORTED_MODULE_3__["default"])(svg, data.title, data.pic, data.supportingBackgroundColor, data.sensitivity, options, status);\r\n    }\r\n    if (options.type === "banner" && (0,_types_guards__WEBPACK_IMPORTED_MODULE_1__.isBannerEntity)(data)) {\r\n        return (0,_banner__WEBPACK_IMPORTED_MODULE_2__["default"])(svg, data, options);\r\n    }\r\n    if (options.type === "node" && (0,_types_guards__WEBPACK_IMPORTED_MODULE_1__.isNodeEntity)(data)) {\r\n        return (0,_base__WEBPACK_IMPORTED_MODULE_3__["default"])(svg, data.title, data.pic, data.supportingBackgroundColor, "safe", options, status);\r\n    }\r\n    if (options.type === "network" && (0,_types_guards__WEBPACK_IMPORTED_MODULE_1__.isNetworkEntity)(data)) {\r\n        return (0,_base__WEBPACK_IMPORTED_MODULE_3__["default"])(svg, data.title, data.pic, data.supportingBackgroundColor, "safe", options, status);\r\n    }\r\n    if (options.type === "app" && (0,_types_guards__WEBPACK_IMPORTED_MODULE_1__.isAppEntity)(data)) {\r\n        return (0,_base__WEBPACK_IMPORTED_MODULE_3__["default"])(svg, data.title, data.pic, data.supportingBackgroundColor, "safe", options, status);\r\n    }\r\n    throw new Error("svg couldn\'t be generated.");\r\n};\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (updateSvg);\r\n\n\n//# sourceURL=webpack:///./src/svgUpdator/index.ts?')},"./src/svgUpdator/lp.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _modules_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../modules/helpers */ "./src/modules/helpers.ts");\n/* harmony import */ var _templates_LPTokenSVG__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../templates/LPTokenSVG */ "./src/templates/LPTokenSVG.ts");\n\r\n\r\n/**\r\n * update the lp token elements with final data, there is two case in lp tokens because the element\'s inital template is the base template\r\n * but when the API specifies that it must be lp, we must reconstruct it\r\n * in the case when the element has a complex-token-type of lp, the template is correct and it will be updated\r\n */\r\nconst updateLpTokenSvg = (initialSvg, data, options, status) => {\r\n    const uniqueID = initialSvg.getAttribute("data-unique-id");\r\n    const strokeWidth = options.strokeWidth || 0;\r\n    const mustPicture0BeCensored = (0,_modules_helpers__WEBPACK_IMPORTED_MODULE_0__.mustBeCensored)(options.censor, data.token0.sensitivity);\r\n    const mustPicture1BeCensored = (0,_modules_helpers__WEBPACK_IMPORTED_MODULE_0__.mustBeCensored)(options.censor, data.token1.sensitivity);\r\n    const contextData = (0,_modules_helpers__WEBPACK_IMPORTED_MODULE_0__.getContextData)(options, data);\r\n    if (initialSvg && initialSvg?.getAttribute("data-template-type") === "lp") {\r\n        // token0\r\n        (0,_templates_LPTokenSVG__WEBPACK_IMPORTED_MODULE_1__.setLpTokenFilters)(initialSvg, uniqueID, mustPicture0BeCensored, mustPicture1BeCensored);\r\n        const supportingBg0 = initialSvg.querySelector("#token0-bg-circle");\r\n        if (supportingBg0) {\r\n            supportingBg0.setAttribute("fill", data.token0.supportingBackgroundColor || "transparent");\r\n        }\r\n        const image0Elem = initialSvg.querySelector("#token0-image");\r\n        if (image0Elem) {\r\n            image0Elem.setAttribute("href", data.token0.pic);\r\n            if (mustPicture0BeCensored)\r\n                image0Elem.setAttribute("filter", `url(#blur0-${uniqueID})`);\r\n        }\r\n        const token0CircleElem = initialSvg.querySelector("#token0-circle");\r\n        if (token0CircleElem) {\r\n            if (status === "success")\r\n                token0CircleElem.setAttribute("stroke-width", `${strokeWidth}`);\r\n            if (!mustPicture0BeCensored) {\r\n                const mainTitle0Elem = token0CircleElem?.firstElementChild;\r\n                if (mainTitle0Elem)\r\n                    mainTitle0Elem.textContent = data.token0.title || data.token0.address;\r\n            }\r\n        }\r\n        // token1\r\n        const supportingBg1 = initialSvg.querySelector("#token1-bg-circle");\r\n        if (supportingBg1) {\r\n            supportingBg1.setAttribute("fill", data.token1.supportingBackgroundColor || "transparent");\r\n        }\r\n        const image1Elem = initialSvg.querySelector("#token1-image");\r\n        if (image1Elem) {\r\n            image1Elem.setAttribute("href", data.token1.pic);\r\n            if (mustPicture1BeCensored)\r\n                image1Elem.setAttribute("filter", `url(#blur1-${uniqueID})`);\r\n        }\r\n        const token1PathCircleElem = initialSvg.querySelector("#token1-circle");\r\n        if (token1PathCircleElem) {\r\n            if (status === "success")\r\n                token1PathCircleElem.setAttribute("stroke-width", `${strokeWidth}`);\r\n            if (!mustPicture1BeCensored) {\r\n                const mainTitle1Elem = token1PathCircleElem?.firstElementChild;\r\n                if (mainTitle1Elem)\r\n                    mainTitle1Elem.textContent = data.token1.title || data.token1.address;\r\n            }\r\n        }\r\n        // context\r\n        const contextImageElem = initialSvg.querySelector("#context-image");\r\n        const contextCircleElem = initialSvg.querySelector("#context-circle");\r\n        if (contextImageElem && contextCircleElem && contextData.type !== "none") {\r\n            const contextBg = initialSvg.querySelector("#context-bg-circle");\r\n            if (contextBg) {\r\n                contextBg.setAttribute("fill", contextData.supportingBackgroundColor || "transparent");\r\n            }\r\n            contextImageElem.setAttribute("href", contextData.pic || "");\r\n            if (status === "success" && contextData.pic)\r\n                contextCircleElem.setAttribute("stroke-width", `${strokeWidth}`);\r\n            const contextTitle = contextCircleElem.firstElementChild;\r\n            if (contextTitle)\r\n                contextTitle.textContent = contextData.title;\r\n        }\r\n        return;\r\n    }\r\n    const token0CircleData = (0,_templates_LPTokenSVG__WEBPACK_IMPORTED_MODULE_1__.getLpToken0CircleData)();\r\n    const token1CircleData = (0,_templates_LPTokenSVG__WEBPACK_IMPORTED_MODULE_1__.getLpToken1CircleData)();\r\n    const contextCircleData = (0,_templates_LPTokenSVG__WEBPACK_IMPORTED_MODULE_1__.getLpTokenContextData)(options, token0CircleData, token1CircleData, strokeWidth);\r\n    // clone the template\r\n    const clonedSvg = document.importNode(_templates_LPTokenSVG__WEBPACK_IMPORTED_MODULE_1__["default"].content, true);\r\n    const svg = clonedSvg.querySelector("svg");\r\n    if (initialSvg && svg) {\r\n        initialSvg.replaceWith(svg);\r\n        (0,_templates_LPTokenSVG__WEBPACK_IMPORTED_MODULE_1__.setLpPath)(svg, uniqueID, token0CircleData, token1CircleData, contextCircleData);\r\n        (0,_templates_LPTokenSVG__WEBPACK_IMPORTED_MODULE_1__.setLpTokenFilters)(svg, uniqueID, mustPicture0BeCensored, mustPicture1BeCensored);\r\n        (0,_templates_LPTokenSVG__WEBPACK_IMPORTED_MODULE_1__.setLpTokenShapes)(svg, uniqueID, token0CircleData, token1CircleData, mustPicture0BeCensored, mustPicture1BeCensored, data, options.strokeColor || "", strokeWidth, true);\r\n        // context\r\n        if (contextData.type !== "none") {\r\n            (0,_templates_LPTokenSVG__WEBPACK_IMPORTED_MODULE_1__.setLpContextShapes)(svg, uniqueID, contextCircleData, contextData, options.strokeColor || "", strokeWidth, true);\r\n        }\r\n    }\r\n};\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (updateLpTokenSvg);\r\n\n\n//# sourceURL=webpack:///./src/svgUpdator/lp.ts?')},"./src/templates/LPTokenSVG.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   getLpToken0CircleData: () => (/* binding */ getLpToken0CircleData),\n/* harmony export */   getLpToken1CircleData: () => (/* binding */ getLpToken1CircleData),\n/* harmony export */   getLpTokenContextData: () => (/* binding */ getLpTokenContextData),\n/* harmony export */   setLpContextShapes: () => (/* binding */ setLpContextShapes),\n/* harmony export */   setLpPath: () => (/* binding */ setLpPath),\n/* harmony export */   setLpTokenFilters: () => (/* binding */ setLpTokenFilters),\n/* harmony export */   setLpTokenShapes: () => (/* binding */ setLpTokenShapes)\n/* harmony export */ });\nconst PicsLiquidityTokenTemplate = document.createElement("template");\r\nPicsLiquidityTokenTemplate.innerHTML = `\r\n<svg\r\n\txmlns="http://www.w3.org/2000/svg"\r\n\txmlnsXlink="http://www.w3.org/1999/xlink"\r\n\tversion="1.1"\r\n\tviewBox="0 0 100 100">\r\n\t<defs>\r\n\t\t<clipPath id="token0-path">\r\n\t\t\t<circle></circle>\r\n\t\t</clipPath>\r\n\t\t<clipPath id="token1-path">\r\n\t\t\t<circle></circle>\r\n\t\t</clipPath>\r\n\t\t<clipPath id="context-path">\r\n\t\t\t<circle></circle>\r\n\t\t</clipPath>\r\n\r\n\t\t<filter id="blur0">\r\n\t\t\t<feGaussianBlur in="SourceGraphic" stdDeviation="7" />\r\n\t\t</filter>\r\n\t\t<filter id="blur1">\r\n\t\t\t<feGaussianBlur in="SourceGraphic" stdDeviation="7" />\r\n\t\t</filter>\r\n\t</defs>\r\n\r\n\t<circle id="token0-bg-circle"></circle>\r\n\t<image preserveAspectRatio="xMidYMid slice" id="token0-image"></image>\r\n\t<circle fill="transparent" id="token0-circle"> <title></title></circle>\r\n\r\n\t<circle id="token1-bg-circle"></circle>\r\n\t<image preserveAspectRatio="xMidYMid slice" id="token1-image"></image>\r\n\t<circle fill="transparent" id="token1-circle">\r\n\t\t<title></title>\r\n\t</circle>\r\n\r\n\t<circle id="context-bg-circle"></circle>\r\n\t<image preserveAspectRatio="xMidYMid slice" id="context-image"></image>\r\n\t<circle fill="transparent" id="context-circle">\r\n\t\t<title></title>\r\n\t</circle>\r\n</svg>\r\n`;\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (PicsLiquidityTokenTemplate);\r\nfunction setLpPath(svg, uniqueID, token0CircleData, token1CircleData, contextCircleData) {\r\n    const token0PathElem = svg.querySelector("#token0-path");\r\n    if (token0PathElem) {\r\n        token0PathElem.id = `token0-circle-${uniqueID}`;\r\n        const token0pathCircleElem = token0PathElem.firstElementChild;\r\n        if (token0pathCircleElem) {\r\n            token0pathCircleElem.setAttribute("cx", `${token0CircleData.cx}`);\r\n            token0pathCircleElem.setAttribute("cy", `${token0CircleData.cy}`);\r\n            token0pathCircleElem.setAttribute("r", `${token0CircleData.r}`);\r\n        }\r\n    }\r\n    const token1PathElem = svg.querySelector("#token1-path");\r\n    if (token1PathElem) {\r\n        token1PathElem.id = `token1-circle-${uniqueID}`;\r\n        const token1PathCircleElem = token1PathElem.firstElementChild;\r\n        if (token1PathCircleElem) {\r\n            token1PathCircleElem.setAttribute("cx", `${token1CircleData.cx}`);\r\n            token1PathCircleElem.setAttribute("cy", `${token1CircleData.cy}`);\r\n            token1PathCircleElem.setAttribute("r", `${token1CircleData.r}`);\r\n        }\r\n    }\r\n    const ContextPathElem = svg.querySelector("#context-path");\r\n    if (ContextPathElem) {\r\n        ContextPathElem.id = `context-circle-${uniqueID}`;\r\n        const ContextPathCircleElem = ContextPathElem.firstElementChild;\r\n        if (ContextPathCircleElem) {\r\n            ContextPathCircleElem.setAttribute("cx", `${contextCircleData.cx}`);\r\n            ContextPathCircleElem.setAttribute("cy", `${contextCircleData.cy}`);\r\n            ContextPathCircleElem.setAttribute("r", `${contextCircleData.r}`);\r\n        }\r\n    }\r\n}\r\nfunction setLpTokenFilters(svg, uniqueID, mustPicture0BeCensored, mustPicture1BeCensored) {\r\n    const filter0Elem = svg.querySelector("#blur0");\r\n    if (filter0Elem && mustPicture0BeCensored) {\r\n        filter0Elem.id = `blur0-${uniqueID}`;\r\n    }\r\n    else {\r\n        filter0Elem?.remove();\r\n    }\r\n    const filter1Elem = svg.querySelector("#blur1");\r\n    if (filter1Elem && mustPicture1BeCensored) {\r\n        filter1Elem.id = `blur1-${uniqueID}`;\r\n    }\r\n    else {\r\n        filter1Elem?.remove();\r\n    }\r\n}\r\nfunction setLpTokenShapes(svg, uniqueID, token0CircleData, token1CircleData, mustPicture0BeCensored = false, mustPicture1BeCensored = false, data, strokeColor, strokeWidth, applyStroke) {\r\n    const supportingBg0 = svg.querySelector("#token0-bg-circle");\r\n    if (supportingBg0) {\r\n        supportingBg0.setAttribute("cx", `${token0CircleData.cx}`);\r\n        supportingBg0.setAttribute("cy", `${token0CircleData.cy}`);\r\n        supportingBg0.setAttribute("r", `${token0CircleData.r}`);\r\n        supportingBg0.setAttribute("fill", data.token0.supportingBackgroundColor || "transparent");\r\n    }\r\n    const image0Elem = svg.querySelector("#token0-image");\r\n    if (image0Elem) {\r\n        image0Elem.setAttribute("x", `${token0CircleData.cx - token0CircleData.r}`);\r\n        image0Elem.setAttribute("y", `${token0CircleData.cy - token0CircleData.r}`);\r\n        image0Elem.setAttribute("width", `${2 * token0CircleData.r}`);\r\n        image0Elem.setAttribute("height", `${2 * token0CircleData.r}`);\r\n        image0Elem.setAttribute("href", data.token0.pic);\r\n        image0Elem.setAttribute("clip-path", `url(#token0-circle-${uniqueID})`);\r\n        if (mustPicture0BeCensored)\r\n            image0Elem.setAttribute("filter", `url(#blur0-${uniqueID})`);\r\n    }\r\n    const token0CircleElem = svg.querySelector("#token0-circle");\r\n    if (token0CircleElem) {\r\n        token0CircleElem.setAttribute("cx", `${token0CircleData.cx}`);\r\n        token0CircleElem.setAttribute("cy", `${token0CircleData.cy}`);\r\n        token0CircleElem.setAttribute("r", `${token0CircleData.r}`);\r\n        token0CircleElem.setAttribute("stroke", strokeColor);\r\n        token0CircleElem.setAttribute("stroke-width", String(applyStroke ? strokeWidth : 0));\r\n        const mainTitle0Elem = token0CircleElem?.firstElementChild;\r\n        if (mainTitle0Elem)\r\n            mainTitle0Elem.textContent = data.token0.title || data.token0.address;\r\n    }\r\n    const supportingBg1 = svg.querySelector("#token1-bg-circle");\r\n    if (supportingBg1) {\r\n        supportingBg1.setAttribute("cx", `${token1CircleData.cx}`);\r\n        supportingBg1.setAttribute("cy", `${token1CircleData.cy}`);\r\n        supportingBg1.setAttribute("r", `${token1CircleData.r}`);\r\n        supportingBg1.setAttribute("fill", data.token1.supportingBackgroundColor || "transparent");\r\n    }\r\n    const image1Elem = svg.querySelector("#token1-image");\r\n    if (image1Elem) {\r\n        image1Elem.setAttribute("x", `${token1CircleData.cx - token1CircleData.r}`);\r\n        image1Elem.setAttribute("y", `${token1CircleData.cy - token1CircleData.r}`);\r\n        image1Elem.setAttribute("width", `${2 * token1CircleData.r}`);\r\n        image1Elem.setAttribute("height", `${2 * token1CircleData.r}`);\r\n        image1Elem.setAttribute("href", data.token1.pic);\r\n        image1Elem.setAttribute("clip-path", `url(#token1-circle-${uniqueID})`);\r\n        if (mustPicture1BeCensored)\r\n            image1Elem.setAttribute("filter", `url(#blur1-${uniqueID})`);\r\n    }\r\n    const token1PathCircleElem = svg.querySelector("#token1-circle");\r\n    if (token1PathCircleElem) {\r\n        token1PathCircleElem.setAttribute("cx", `${token1CircleData.cx}`);\r\n        token1PathCircleElem.setAttribute("cy", `${token1CircleData.cy}`);\r\n        token1PathCircleElem.setAttribute("r", `${token1CircleData.r}`);\r\n        token1PathCircleElem.setAttribute("stroke", strokeColor);\r\n        token1PathCircleElem.setAttribute("stroke-width", String(applyStroke ? strokeWidth : 0));\r\n        const mainTitle1Elem = token1PathCircleElem?.firstElementChild;\r\n        if (mainTitle1Elem)\r\n            mainTitle1Elem.textContent = data.token1.title || data.token1.address;\r\n    }\r\n}\r\nfunction setLpContextShapes(svg, uniqueID, contextCircleData, contextData, strokeColor, strokeWidth, applyStroke) {\r\n    const contextImageElem = svg.querySelector("#context-image");\r\n    const contextCircleElem = svg.querySelector("#context-circle");\r\n    if (contextImageElem && contextCircleElem) {\r\n        const contextBg = svg.querySelector("#context-bg-circle");\r\n        if (contextBg) {\r\n            contextBg.setAttribute("cx", `${contextCircleData.cx}`);\r\n            contextBg.setAttribute("cy", `${contextCircleData.cy}`);\r\n            contextBg.setAttribute("r", `${contextCircleData.r}`);\r\n            contextBg.setAttribute("fill", contextData?.supportingBackgroundColor || "transparent");\r\n        }\r\n        contextImageElem.setAttribute("href", contextData?.pic || "");\r\n        contextImageElem.setAttribute("x", String(contextCircleData.cx - contextCircleData.r));\r\n        contextImageElem.setAttribute("y", String(contextCircleData.cy - contextCircleData.r));\r\n        contextImageElem.setAttribute("width", String(2 * contextCircleData.r));\r\n        contextImageElem.setAttribute("height", String(2 * contextCircleData.r));\r\n        contextImageElem.setAttribute("clip-path", `url(#context-circle-${uniqueID})`);\r\n        contextCircleElem.setAttribute("cx", String(contextCircleData.cx));\r\n        contextCircleElem.setAttribute("cy", String(contextCircleData.cy));\r\n        contextCircleElem.setAttribute("r", String(contextCircleData.r));\r\n        contextCircleElem.setAttribute("stroke", strokeColor || "");\r\n        contextCircleElem.setAttribute("stroke-width", String(applyStroke ? strokeWidth : 0));\r\n        contextCircleElem.setAttribute("fill", "transparent");\r\n        const contextTitle = contextCircleElem.firstElementChild;\r\n        if (contextTitle && contextData?.title)\r\n            contextTitle.textContent = contextData.title;\r\n    }\r\n}\r\nfunction getLpToken0CircleData() {\r\n    return { cx: 32.5, cy: 50, r: 25 };\r\n}\r\nfunction getLpToken1CircleData() {\r\n    return { cx: 67.5, cy: 50, r: 25 };\r\n}\r\nfunction getLpTokenContextData(options, token0CircleData, token1CircleData, strokeWidth) {\r\n    const contextRadius = 12.5;\r\n    return {\r\n        r: contextRadius,\r\n        cx: options.contextPosition === "bottomRight" || options.contextPosition === "topRight"\r\n            ? token1CircleData.cx + token1CircleData.r / 2 + contextRadius / 2 - strokeWidth / 2\r\n            : token0CircleData.cx - token0CircleData.r / 2 - contextRadius / 2 + strokeWidth / 2,\r\n        cy: options.contextPosition === "bottomRight" || options.contextPosition === "bottomLeft"\r\n            ? token1CircleData.cy + token1CircleData.r / 2 + contextRadius / 2 - strokeWidth / 2\r\n            : token0CircleData.cy - token0CircleData.r / 2 - contextRadius / 2 + strokeWidth / 2,\r\n    };\r\n}\r\n\n\n//# sourceURL=webpack:///./src/templates/LPTokenSVG.ts?')},"./src/templates/bannerSVG.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nconst PicsBannerSvgTemplate = document.createElement("template");\r\nPicsBannerSvgTemplate.innerHTML = `\r\n<svg xmlns="http://www.w3.org/2000/svg" xmlnsXlink="http://www.w3.org/1999/xlink" viewBox="0 0 400 100">\r\n\t<defs>\r\n\t\t<clipPath>\r\n\t\t\t<rect x="0" y="0" width="400" height="100" />\r\n\t\t</clipPath>\r\n\t\t<filter>\r\n\t\t\t<feGaussianBlur in="SourceGraphic" stdDeviation="7" />\r\n\t\t</filter>\r\n\t</defs>\r\n\r\n\t<rect id="rect-bg" x="0" y="0" width="400" height="100" fill="transparent" ></rect>\r\n\t<image\r\n\t\tx="0"\r\n\t\ty="0"\r\n\t\twidth="400"\r\n\t\theight="100"\r\n\t\tfilter=""\r\n\t\tpreserveAspectRatio="xMidYMid slice"></image>\r\n\r\n\t<rect x="0" y="0" width="400" height="100" fill="transparent" ></rect>\r\n</svg>\r\n`;\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (PicsBannerSvgTemplate);\r\n\n\n//# sourceURL=webpack:///./src/templates/bannerSVG.ts?')},"./src/templates/baseSVG.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   setBaseBgRect: () => (/* binding */ setBaseBgRect),\n/* harmony export */   setBaseFilter: () => (/* binding */ setBaseFilter),\n/* harmony export */   setBaseImage: () => (/* binding */ setBaseImage),\n/* harmony export */   setBasePathRect: () => (/* binding */ setBasePathRect),\n/* harmony export */   setBaseRect: () => (/* binding */ setBaseRect)\n/* harmony export */ });\n/* harmony import */ var _modules_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../modules/helpers */ "./src/modules/helpers.ts");\n\r\nconst PicsBaseSvgTemplate = document.createElement("template");\r\nPicsBaseSvgTemplate.innerHTML = `\r\n<svg xmlns="http://www.w3.org/2000/svg" xmlnsXlink="http://www.w3.org/1999/xlink" viewBox="0 0 100 100">\r\n\t<defs>\r\n\t\t<clipPath>\r\n\t\t\t<rect></rect>\r\n\t\t</clipPath>\r\n\t\t<filter>\r\n\t\t\t<feGaussianBlur in="SourceGraphic" stdDeviation="7" />\r\n\t\t</filter>\r\n\t</defs>\r\n\r\n\t<rect id="bg-color" fill="transparent"></rect>\r\n\t<image preserveAspectRatio="xMidYMid slice"></image>\r\n\t<rect fill="transparent" id="mask">\r\n\t\t<title></title>\r\n\t</rect>\r\n</svg>\r\n`;\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (PicsBaseSvgTemplate);\r\n/** setup the rect shape of the base svg */\r\nconst setBasePathRect = (svg, uniqueID, strokeWidth, shape) => {\r\n    const pathElem = svg.querySelector("clipPath");\r\n    if (pathElem) {\r\n        pathElem.id = `rect-${uniqueID}`;\r\n        const pathRectElem = pathElem.firstElementChild;\r\n        if (pathRectElem) {\r\n            pathRectElem.setAttribute("x", `${strokeWidth / 2}`);\r\n            pathRectElem.setAttribute("y", `${strokeWidth / 2}`);\r\n            pathRectElem.setAttribute("width", `${100 - strokeWidth}`);\r\n            pathRectElem.setAttribute("height", `${100 - strokeWidth}`);\r\n            pathRectElem.setAttribute("rx", (0,_modules_helpers__WEBPACK_IMPORTED_MODULE_0__.getShapeRadius)(shape, 100));\r\n            pathRectElem.setAttribute("ry", (0,_modules_helpers__WEBPACK_IMPORTED_MODULE_0__.getShapeRadius)(shape, 100));\r\n        }\r\n    }\r\n};\r\nconst setBaseBgRect = (svg, bgColor, strokeWidth, shape) => {\r\n    const bgColorElem = svg.querySelector(`#bg-color`);\r\n    if (bgColorElem) {\r\n        bgColorElem.setAttribute("x", `${strokeWidth / 2}`);\r\n        bgColorElem.setAttribute("y", `${strokeWidth / 2}`);\r\n        bgColorElem.setAttribute("width", `${100 - strokeWidth}`);\r\n        bgColorElem.setAttribute("height", `${100 - strokeWidth}`);\r\n        bgColorElem.setAttribute("rx", (0,_modules_helpers__WEBPACK_IMPORTED_MODULE_0__.getShapeRadius)(shape, 100));\r\n        bgColorElem.setAttribute("ry", (0,_modules_helpers__WEBPACK_IMPORTED_MODULE_0__.getShapeRadius)(shape, 100));\r\n        bgColorElem.setAttribute("fill", bgColor || "transparent");\r\n    }\r\n};\r\nconst setBaseImage = (svg, pictureUrl, uniqueID, strokeWidth) => {\r\n    const imageElem = svg.querySelector("image");\r\n    if (imageElem) {\r\n        imageElem.setAttribute("x", `${strokeWidth / 2}`);\r\n        imageElem.setAttribute("y", `${strokeWidth / 2}`);\r\n        imageElem.setAttribute("width", `${100 - strokeWidth}`);\r\n        imageElem.setAttribute("height", `${100 - strokeWidth}`);\r\n        imageElem.setAttribute("href", pictureUrl);\r\n        imageElem.setAttribute("clip-path", `url(#rect-${uniqueID})`);\r\n    }\r\n};\r\nconst setBaseRect = (svg, title, strokeWidth, options, applyStroke = false) => {\r\n    const rectElem = svg.querySelector("#mask");\r\n    if (rectElem) {\r\n        rectElem.setAttribute("x", `${strokeWidth / 2}`);\r\n        rectElem.setAttribute("y", `${strokeWidth / 2}`);\r\n        rectElem.setAttribute("width", `${100 - strokeWidth}`);\r\n        rectElem.setAttribute("height", `${100 - strokeWidth}`);\r\n        rectElem.setAttribute("rx", (0,_modules_helpers__WEBPACK_IMPORTED_MODULE_0__.getShapeRadius)(options.shape, 100));\r\n        rectElem.setAttribute("ry", (0,_modules_helpers__WEBPACK_IMPORTED_MODULE_0__.getShapeRadius)(options.shape, 100));\r\n        rectElem.setAttribute("stroke", options.strokeColor || "");\r\n        rectElem.setAttribute("stroke-width", String(applyStroke ? strokeWidth : 0));\r\n        if (rectElem?.firstElementChild)\r\n            rectElem.firstElementChild.textContent = title || "";\r\n    }\r\n};\r\nfunction setBaseFilter(svg, mustPictureBeCensored, uniqueID) {\r\n    const filterElem = svg.querySelector("filter");\r\n    if (filterElem && mustPictureBeCensored) {\r\n        filterElem.id = `blur-${uniqueID}`;\r\n        return;\r\n    }\r\n    filterElem?.remove();\r\n}\r\n\n\n//# sourceURL=webpack:///./src/templates/baseSVG.ts?')},"./src/templates/contextualTokenSVG.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   getContextualContextShapeData: () => (/* binding */ getContextualContextShapeData),\n/* harmony export */   getContextualTokenShapeData: () => (/* binding */ getContextualTokenShapeData),\n/* harmony export */   setContextualContextShape: () => (/* binding */ setContextualContextShape),\n/* harmony export */   setContextualFilter: () => (/* binding */ setContextualFilter),\n/* harmony export */   setContextualPath: () => (/* binding */ setContextualPath),\n/* harmony export */   setContextualTokenShapes: () => (/* binding */ setContextualTokenShapes)\n/* harmony export */ });\nconst PicsContextualTokenTemplate = document.createElement("template");\r\nPicsContextualTokenTemplate.innerHTML = `\r\n<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 100 100">\r\n\t<defs>\r\n\t\t<clipPath id="contextual-path">\r\n\t\t\t<circle cx="0" cy="0" r="0"></circle>\r\n\t\t</clipPath>\r\n\t\t<clipPath id="context-path">\r\n\t\t\t<circle cx="0" cy="0" r="0"></circle>\r\n\t\t</clipPath>\r\n\r\n\t\t<filter id="contextual-blur">\r\n\t\t\t<feGaussianBlur in="SourceGraphic" stdDeviation="7" />\r\n\t\t</filter>\r\n\t</defs>\r\n\r\n\t<circle id="contextual-bg-circle" fill="transparent"></circle>\r\n\t<image\r\n\t\tid="contextual-image"\r\n\t\tpreserveAspectRatio="xMidYMid slice">\r\n\t</image>\r\n\t<circle\r\n\t\tid="contextual-circle"\r\n\t\tfill="transparent">\r\n\t\t<title></title>\r\n\t</circle>\r\n\r\n\t<circle id="context-bg-circle" fill="transparent"></circle>\r\n\t<image\r\n\t\tid="context-image"\r\n\t\tpreserveAspectRatio="xMidYMid slice">\r\n\t</image>\r\n\t<circle\r\n\t\tid="context-circle"\r\n\t\tfill="transparent">\r\n\t\t<title></title>\r\n\t</circle>\r\n</svg>\r\n`;\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (PicsContextualTokenTemplate);\r\nfunction setContextualPath(svg, uniqueID, tokenCircleData, contextCircleData) {\r\n    const tokenPathElem = svg.querySelector("#contextual-path");\r\n    if (tokenPathElem) {\r\n        tokenPathElem.id = `contextual-circle-${uniqueID}`;\r\n        const tokenPathCircleElem = tokenPathElem.firstElementChild;\r\n        if (tokenPathCircleElem) {\r\n            tokenPathCircleElem.setAttribute("cx", `${tokenCircleData.cx}`);\r\n            tokenPathCircleElem.setAttribute("cy", `${tokenCircleData.cy}`);\r\n            tokenPathCircleElem.setAttribute("r", `${tokenCircleData.r}`);\r\n        }\r\n    }\r\n    const contextPathElem = svg.querySelector("#context-path");\r\n    if (contextPathElem) {\r\n        contextPathElem.id = `context-circle-${uniqueID}`;\r\n        const contextPathCircleElem = contextPathElem.firstElementChild;\r\n        if (contextPathCircleElem) {\r\n            contextPathCircleElem.setAttribute("cx", `${contextCircleData.cx}`);\r\n            contextPathCircleElem.setAttribute("cy", `${contextCircleData.cy}`);\r\n            contextPathCircleElem.setAttribute("r", `${contextCircleData.r}`);\r\n        }\r\n    }\r\n}\r\nfunction setContextualTokenShapes(svg, uniqueID, tokenCircleData, mustBeCensored = false, pictureUrl, title, supportingBackgroundColor, strokeWidth, strokeColor, applyStroke = false) {\r\n    const bgElem = svg.querySelector("#contextual-bg-circle");\r\n    if (bgElem) {\r\n        bgElem.setAttribute("cx", `${tokenCircleData.cx}`);\r\n        bgElem.setAttribute("cy", `${tokenCircleData.cy}`);\r\n        bgElem.setAttribute("r", `${tokenCircleData.r}`);\r\n        bgElem.setAttribute("fill", supportingBackgroundColor || "transparent");\r\n    }\r\n    const imageElem = svg.querySelector("#contextual-image");\r\n    if (imageElem) {\r\n        imageElem.setAttribute("x", `${tokenCircleData.cx - tokenCircleData.r}`);\r\n        imageElem.setAttribute("y", `${tokenCircleData.cy - tokenCircleData.r}`);\r\n        imageElem.setAttribute("width", `${2 * tokenCircleData.r}`);\r\n        imageElem.setAttribute("height", `${2 * tokenCircleData.r}`);\r\n        imageElem.setAttribute("href", pictureUrl);\r\n        imageElem.setAttribute("clip-path", `url(#contextual-circle-${uniqueID})`);\r\n        if (mustBeCensored)\r\n            imageElem.setAttribute("filter", `url(#contextual-blur-${uniqueID})`);\r\n    }\r\n    const tokenCircleElem = svg.querySelector("#contextual-circle");\r\n    if (tokenCircleElem) {\r\n        tokenCircleElem.setAttribute("cx", `${tokenCircleData.cx}`);\r\n        tokenCircleElem.setAttribute("cy", `${tokenCircleData.cy}`);\r\n        tokenCircleElem.setAttribute("r", `${tokenCircleData.r}`);\r\n        tokenCircleElem.setAttribute("stroke", strokeColor);\r\n        tokenCircleElem.setAttribute("stroke-width", String(applyStroke ? strokeWidth : 0));\r\n        const mainTitleElem = tokenCircleElem.firstElementChild;\r\n        if (mainTitleElem)\r\n            mainTitleElem.textContent = title || "";\r\n    }\r\n}\r\nfunction setContextualContextShape(svg, uniqueID, contextCircleData, pictureUrl, title, supportingBackgroundColor, strokeWidth, strokeColor, applyStroke = false) {\r\n    const contextImageElem = svg.querySelector("#context-image");\r\n    const contextCircleElem = svg.querySelector("#context-circle");\r\n    if (contextImageElem && contextCircleElem) {\r\n        const contextBgElem = svg.querySelector("#context-bg-circle");\r\n        if (contextBgElem) {\r\n            contextBgElem.setAttribute("cx", String(contextCircleData.cx));\r\n            contextBgElem.setAttribute("cy", String(contextCircleData.cy));\r\n            contextBgElem.setAttribute("r", String(contextCircleData.r));\r\n            contextBgElem.setAttribute("fill", supportingBackgroundColor || "transparent");\r\n        }\r\n        contextImageElem.setAttribute("href", pictureUrl || "");\r\n        contextImageElem.setAttribute("x", String(contextCircleData.cx - contextCircleData.r));\r\n        contextImageElem.setAttribute("y", String(contextCircleData.cy - contextCircleData.r));\r\n        contextImageElem.setAttribute("width", String(2 * contextCircleData.r));\r\n        contextImageElem.setAttribute("height", String(2 * contextCircleData.r));\r\n        contextImageElem.setAttribute("clip-path", `url(#context-circle-${uniqueID})`);\r\n        contextCircleElem.setAttribute("cx", String(contextCircleData.cx));\r\n        contextCircleElem.setAttribute("cy", String(contextCircleData.cy));\r\n        contextCircleElem.setAttribute("r", String(contextCircleData.r));\r\n        contextCircleElem.setAttribute("stroke", strokeColor);\r\n        contextCircleElem.setAttribute("stroke-width", String(applyStroke ? strokeWidth : 0));\r\n        contextCircleElem.setAttribute("fill", "transparent");\r\n        const contextTitleElem = contextCircleElem.firstElementChild;\r\n        if (contextTitleElem && title)\r\n            contextTitleElem.textContent = title;\r\n    }\r\n}\r\nfunction setContextualFilter(svg, uniqueID, mustPictureBeCensored) {\r\n    const filterElem = svg.querySelector("#contextual-blur");\r\n    if (filterElem && mustPictureBeCensored) {\r\n        filterElem.id = `contextual-blur-${uniqueID}`;\r\n    }\r\n    else {\r\n        filterElem?.remove();\r\n    }\r\n}\r\nfunction getContextualTokenShapeData() {\r\n    return { cx: 50, cy: 50, r: 40 };\r\n}\r\nfunction getContextualContextShapeData(options, tokenCircleData, strokeWidth) {\r\n    const contextCircleRadius = 20;\r\n    return {\r\n        cx: options.contextPosition === "bottomRight" || options.contextPosition === "topRight"\r\n            ? tokenCircleData.cx + tokenCircleData.r - contextCircleRadius / 2 - strokeWidth / 2\r\n            : tokenCircleData.cx - tokenCircleData.r + contextCircleRadius / 2 + strokeWidth / 2,\r\n        cy: options.contextPosition === "bottomRight" || options.contextPosition === "bottomLeft"\r\n            ? tokenCircleData.cy + tokenCircleData.r - contextCircleRadius / 2 - strokeWidth / 2\r\n            : tokenCircleData.cy - tokenCircleData.r + contextCircleRadius / 2 + strokeWidth / 2,\r\n        r: contextCircleRadius,\r\n    };\r\n}\r\n\n\n//# sourceURL=webpack:///./src/templates/contextualTokenSVG.ts?')},"./src/types/guards.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isAppEntity: () => (/* binding */ isAppEntity),\n/* harmony export */   isBannerEntity: () => (/* binding */ isBannerEntity),\n/* harmony export */   isEntityResponseEmpty: () => (/* binding */ isEntityResponseEmpty),\n/* harmony export */   isLpTokenEntity: () => (/* binding */ isLpTokenEntity),\n/* harmony export */   isNetworkEntity: () => (/* binding */ isNetworkEntity),\n/* harmony export */   isNodeEntity: () => (/* binding */ isNodeEntity),\n/* harmony export */   isPicsContextPositionType: () => (/* binding */ isPicsContextPositionType),\n/* harmony export */   isPicsContextType: () => (/* binding */ isPicsContextType),\n/* harmony export */   isPicsSensitivityType: () => (/* binding */ isPicsSensitivityType),\n/* harmony export */   isPicsShapeType: () => (/* binding */ isPicsShapeType),\n/* harmony export */   isPicsType: () => (/* binding */ isPicsType),\n/* harmony export */   isProfileEntity: () => (/* binding */ isProfileEntity),\n/* harmony export */   isTokenEntity: () => (/* binding */ isTokenEntity),\n/* harmony export */   isWrappedTokenEntity: () => (/* binding */ isWrappedTokenEntity)\n/* harmony export */ });\n/* harmony import */ var _picsCommonTypes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./picsCommonTypes */ "./src/types/picsCommonTypes.ts");\n\r\nfunction isPicsType(value) {\r\n    // Assuming PicsType is an enum or a union type\r\n    return value !== null && _picsCommonTypes__WEBPACK_IMPORTED_MODULE_0__.picsTypes.includes(value);\r\n}\r\nfunction isPicsContextType(value) {\r\n    return value !== null && _picsCommonTypes__WEBPACK_IMPORTED_MODULE_0__.picsContextTypes.includes(value);\r\n}\r\nfunction isPicsContextPositionType(value) {\r\n    return value !== null && _picsCommonTypes__WEBPACK_IMPORTED_MODULE_0__.picsContextPositionTypes.includes(value);\r\n}\r\nfunction isPicsShapeType(value) {\r\n    return value !== null && _picsCommonTypes__WEBPACK_IMPORTED_MODULE_0__.picsShapeTypes.includes(value);\r\n}\r\nfunction isPicsSensitivityType(value) {\r\n    return value !== null && _picsCommonTypes__WEBPACK_IMPORTED_MODULE_0__.picsSensitivityTypes.includes(value);\r\n}\r\n// data\r\nfunction isTokenEntity(value) {\r\n    return value && (value?.type === "TOKEN" || value?.type === "CURRENCY");\r\n}\r\nfunction isLpTokenEntity(value) {\r\n    return value && value?.type === "LP" && value?.token0 && value?.token1;\r\n}\r\nfunction isWrappedTokenEntity(value) {\r\n    return value && value?.type === "WRAPPED" && value?.originalToken;\r\n}\r\nfunction isProfileEntity(value) {\r\n    return value && value?.address;\r\n}\r\nfunction isBannerEntity(value) {\r\n    return value && value?.address;\r\n}\r\nfunction isNodeEntity(value) {\r\n    return value && value?.address;\r\n}\r\nfunction isNetworkEntity(value) {\r\n    return value && value?.id;\r\n}\r\nfunction isAppEntity(value) {\r\n    return value && value?.name;\r\n}\r\nfunction isEntityResponseEmpty(obj) {\r\n    return !obj || Object.keys(obj).length === 0;\r\n}\r\n\n\n//# sourceURL=webpack:///./src/types/guards.ts?')},"./src/types/picsCommonTypes.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   picsContextPositionTypes: () => (/* binding */ picsContextPositionTypes),\n/* harmony export */   picsContextTypes: () => (/* binding */ picsContextTypes),\n/* harmony export */   picsSensitivityTypes: () => (/* binding */ picsSensitivityTypes),\n/* harmony export */   picsShapeTypes: () => (/* binding */ picsShapeTypes),\n/* harmony export */   picsTokenTypes: () => (/* binding */ picsTokenTypes),\n/* harmony export */   picsTypes: () => (/* binding */ picsTypes)\n/* harmony export */ });\nconst picsTypes = ["token", "profile", "banner", "node", "network", "app"];\r\nconst picsTokenTypes = ["token", "lp", "wrapped", "currency"];\r\nconst picsContextTypes = ["none", "app", "network"];\r\nconst picsContextPositionTypes = ["topRight", "topLeft", "bottomRight", "bottomLeft"];\r\nconst picsShapeTypes = ["circle", "square", "smoothSquare"];\r\nconst picsSensitivityTypes = ["safe", "sensitive", "inappropriate", "copyright-violated"];\r\n\n\n//# sourceURL=webpack:///./src/types/picsCommonTypes.ts?')}},__webpack_module_cache__={};function __webpack_require__(e){var t=__webpack_module_cache__[e];if(void 0!==t)return t.exports;var r=__webpack_module_cache__[e]={exports:{}};return __webpack_modules__[e](r,r.exports,__webpack_require__),r.exports}__webpack_require__.d=(e,t)=>{for(var r in t)__webpack_require__.o(t,r)&&!__webpack_require__.o(e,r)&&Object.defineProperty(e,r,{enumerable:!0,get:t[r]})},__webpack_require__.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),__webpack_require__.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})};var __webpack_exports__=__webpack_require__("./src/index.ts")})();